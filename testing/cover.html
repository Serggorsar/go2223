
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>testing: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">testing/allocs.go (100.0%)</option>
				
				<option value="file1">testing/benchmark.go (68.1%)</option>
				
				<option value="file2">testing/cover.go (57.9%)</option>
				
				<option value="file3">testing/example.go (10.5%)</option>
				
				<option value="file4">testing/fuzz.go (51.4%)</option>
				
				<option value="file5">testing/match.go (93.2%)</option>
				
				<option value="file6">testing/run_example.go (0.0%)</option>
				
				<option value="file7">testing/testing.go (68.4%)</option>
				
				<option value="file8">testing/testing_other.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "runtime"
)

// AllocsPerRun returns the average number of allocations during calls to f.
// Although the return value has type float64, it will always be an integral value.
//
// To compute the number of allocations, the function will first be run once as
// a warm-up. The average number of allocations over the specified number of
// runs will then be measured and returned.
//
// AllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore
// it before returning.
func AllocsPerRun(runs int, f func()) (avg float64) <span class="cov8" title="1">{
        defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1))

        // Warm up the function
        f()

        // Measure the starting statistics
        var memstats runtime.MemStats
        runtime.ReadMemStats(&amp;memstats)
        mallocs := 0 - memstats.Mallocs

        // Run the function the specified number of times
        for i := 0; i &lt; runs; i++ </span><span class="cov8" title="1">{
                f()
        }</span>

        // Read the final statistics
        <span class="cov8" title="1">runtime.ReadMemStats(&amp;memstats)
        mallocs += memstats.Mallocs

        // Average the mallocs over the runs (not counting the warm-up).
        // We are forced to return a float64 because the API is silly, but do
        // the division as integers so we can ask if AllocsPerRun()==1
        // instead of AllocsPerRun()&lt;2.
        return float64(mallocs / uint64(runs))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "flag"
        "fmt"
        "internal/race"
        "internal/sysinfo"
        "io"
        "math"
        "os"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
        "unicode"
)

func initBenchmarkFlags() <span class="cov8" title="1">{
        matchBenchmarks = flag.String("test.bench", "", "run only benchmarks matching `regexp`")
        benchmarkMemory = flag.Bool("test.benchmem", false, "print memory allocations for benchmarks")
        flag.Var(&amp;benchTime, "test.benchtime", "run each benchmark for duration `d`")
}</span>

var (
        matchBenchmarks *string
        benchmarkMemory *bool

        benchTime = durationOrCountFlag{d: 1 * time.Second} // changed during test of testing package
)

type durationOrCountFlag struct {
        d         time.Duration
        n         int
        allowZero bool
}

func (f *durationOrCountFlag) String() string <span class="cov8" title="1">{
        if f.n &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dx", f.n)
        }</span>
        <span class="cov8" title="1">return f.d.String()</span>
}

func (f *durationOrCountFlag) Set(s string) error <span class="cov0" title="0">{
        if strings.HasSuffix(s, "x") </span><span class="cov0" title="0">{
                n, err := strconv.ParseInt(s[:len(s)-1], 10, 0)
                if err != nil || n &lt; 0 || (!f.allowZero &amp;&amp; n == 0) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid count")
                }</span>
                <span class="cov0" title="0">*f = durationOrCountFlag{n: int(n)}
                return nil</span>
        }
        <span class="cov0" title="0">d, err := time.ParseDuration(s)
        if err != nil || d &lt; 0 || (!f.allowZero &amp;&amp; d == 0) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid duration")
        }</span>
        <span class="cov0" title="0">*f = durationOrCountFlag{d: d}
        return nil</span>
}

// Global lock to ensure only one benchmark runs at a time.
var benchmarkLock sync.Mutex

// Used for every benchmark for measuring memory.
var memStats runtime.MemStats

// InternalBenchmark is an internal type but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
type InternalBenchmark struct {
        Name string
        F    func(b *B)
}

// B is a type passed to Benchmark functions to manage benchmark
// timing and to specify the number of iterations to run.
//
// A benchmark ends when its Benchmark function returns or calls any of the methods
// FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called
// only from the goroutine running the Benchmark function.
// The other reporting methods, such as the variations of Log and Error,
// may be called simultaneously from multiple goroutines.
//
// Like in tests, benchmark logs are accumulated during execution
// and dumped to standard output when done. Unlike in tests, benchmark logs
// are always printed, so as not to hide output whose existence may be
// affecting benchmark results.
type B struct {
        common
        importPath       string // import path of the package containing the benchmark
        context          *benchContext
        N                int
        previousN        int           // number of iterations in the previous run
        previousDuration time.Duration // total duration of the previous run
        benchFunc        func(b *B)
        benchTime        durationOrCountFlag
        bytes            int64
        missingBytes     bool // one of the subbenchmarks does not have bytes set.
        timerOn          bool
        showAllocResult  bool
        result           BenchmarkResult
        parallelism      int // RunParallel creates parallelism*GOMAXPROCS goroutines
        // The initial states of memStats.Mallocs and memStats.TotalAlloc.
        startAllocs uint64
        startBytes  uint64
        // The net total of this test after being run.
        netAllocs uint64
        netBytes  uint64
        // Extra metrics collected by ReportMetric.
        extra map[string]float64
}

// StartTimer starts timing a test. This function is called automatically
// before a benchmark starts, but it can also be used to resume timing after
// a call to StopTimer.
func (b *B) StartTimer() <span class="cov8" title="1">{
        if !b.timerOn </span><span class="cov8" title="1">{
                runtime.ReadMemStats(&amp;memStats)
                b.startAllocs = memStats.Mallocs
                b.startBytes = memStats.TotalAlloc
                b.start = time.Now()
                b.timerOn = true
        }</span>
}

// StopTimer stops timing a test. This can be used to pause the timer
// while performing complex initialization that you don't
// want to measure.
func (b *B) StopTimer() <span class="cov8" title="1">{
        if b.timerOn </span><span class="cov8" title="1">{
                b.duration += time.Since(b.start)
                runtime.ReadMemStats(&amp;memStats)
                b.netAllocs += memStats.Mallocs - b.startAllocs
                b.netBytes += memStats.TotalAlloc - b.startBytes
                b.timerOn = false
        }</span>
}

// ResetTimer zeroes the elapsed benchmark time and memory allocation counters
// and deletes user-reported metrics.
// It does not affect whether the timer is running.
func (b *B) ResetTimer() <span class="cov8" title="1">{
        if b.extra == nil </span><span class="cov8" title="1">{
                // Allocate the extra map before reading memory stats.
                // Pre-size it to make more allocation unlikely.
                b.extra = make(map[string]float64, 16)
        }</span> else<span class="cov8" title="1"> {
                for k := range b.extra </span><span class="cov8" title="1">{
                        delete(b.extra, k)
                }</span>
        }
        <span class="cov8" title="1">if b.timerOn </span><span class="cov0" title="0">{
                runtime.ReadMemStats(&amp;memStats)
                b.startAllocs = memStats.Mallocs
                b.startBytes = memStats.TotalAlloc
                b.start = time.Now()
        }</span>
        <span class="cov8" title="1">b.duration = 0
        b.netAllocs = 0
        b.netBytes = 0</span>
}

// SetBytes records the number of bytes processed in a single operation.
// If this is called, the benchmark will report ns/op and MB/s.
func (b *B) SetBytes(n int64) <span class="cov8" title="1">{ b.bytes = n }</span>

// ReportAllocs enables malloc statistics for this benchmark.
// It is equivalent to setting -test.benchmem, but it only affects the
// benchmark function that calls ReportAllocs.
func (b *B) ReportAllocs() <span class="cov8" title="1">{
        b.showAllocResult = true
}</span>

// runN runs a single benchmark for the specified number of iterations.
func (b *B) runN(n int) <span class="cov8" title="1">{
        benchmarkLock.Lock()
        defer benchmarkLock.Unlock()
        defer b.runCleanup(normalPanic)
        // Try to get a comparable environment for each run
        // by clearing garbage from previous runs.
        runtime.GC()
        b.raceErrors = -race.Errors()
        b.N = n
        b.parallelism = 1
        b.ResetTimer()
        b.StartTimer()
        b.benchFunc(b)
        b.StopTimer()
        b.previousN = n
        b.previousDuration = b.duration
        b.raceErrors += race.Errors()
        if b.raceErrors &gt; 0 </span><span class="cov0" title="0">{
                b.Errorf("race detected during execution of benchmark")
        }</span>
}

func min(x, y int64) int64 <span class="cov8" title="1">{
        if x &gt; y </span><span class="cov8" title="1">{
                return y
        }</span>
        <span class="cov8" title="1">return x</span>
}

func max(x, y int64) int64 <span class="cov8" title="1">{
        if x &lt; y </span><span class="cov0" title="0">{
                return y
        }</span>
        <span class="cov8" title="1">return x</span>
}

// run1 runs the first iteration of benchFunc. It reports whether more
// iterations of this benchmarks should be run.
func (b *B) run1() bool <span class="cov8" title="1">{
        if ctx := b.context; ctx != nil </span><span class="cov0" title="0">{
                // Extend maxLen, if needed.
                if n := len(b.name) + ctx.extLen + 1; n &gt; ctx.maxLen </span><span class="cov0" title="0">{
                        ctx.maxLen = n + 8 // Add additional slack to avoid too many jumps in size.
                }</span>
        }
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                // Signal that we're done whether we return normally
                // or by FailNow's runtime.Goexit.
                defer func() </span><span class="cov8" title="1">{
                        b.signal &lt;- true
                }</span>()

                <span class="cov8" title="1">b.runN(1)</span>
        }()
        <span class="cov8" title="1">&lt;-b.signal
        if b.failed </span><span class="cov8" title="1">{
                fmt.Fprintf(b.w, "--- FAIL: %s\n%s", b.name, b.output)
                return false
        }</span>
        // Only print the output if we know we are not going to proceed.
        // Otherwise it is printed in processBench.
        <span class="cov8" title="1">b.mu.RLock()
        finished := b.finished
        b.mu.RUnlock()
        if atomic.LoadInt32(&amp;b.hasSub) != 0 || finished </span><span class="cov8" title="1">{
                tag := "BENCH"
                if b.skipped </span><span class="cov8" title="1">{
                        tag = "SKIP"
                }</span>
                <span class="cov8" title="1">if b.chatty != nil &amp;&amp; (len(b.output) &gt; 0 || finished) </span><span class="cov8" title="1">{
                        b.trimOutput()
                        fmt.Fprintf(b.w, "--- %s: %s\n%s", tag, b.name, b.output)
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

var labelsOnce sync.Once

// run executes the benchmark in a separate goroutine, including all of its
// subbenchmarks. b must not have subbenchmarks.
func (b *B) run() <span class="cov8" title="1">{
        labelsOnce.Do(func() </span><span class="cov8" title="1">{
                fmt.Fprintf(b.w, "goos: %s\n", runtime.GOOS)
                fmt.Fprintf(b.w, "goarch: %s\n", runtime.GOARCH)
                if b.importPath != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.w, "pkg: %s\n", b.importPath)
                }</span>
                <span class="cov8" title="1">if cpu := sysinfo.CPU.Name(); cpu != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(b.w, "cpu: %s\n", cpu)
                }</span>
        })
        <span class="cov8" title="1">if b.context != nil </span><span class="cov0" title="0">{
                // Running go test --test.bench
                b.context.processBench(b) // Must call doBench.
        }</span> else<span class="cov8" title="1"> {
                // Running func Benchmark.
                b.doBench()
        }</span>
}

func (b *B) doBench() BenchmarkResult <span class="cov8" title="1">{
        go b.launch()
        &lt;-b.signal
        return b.result
}</span>

// launch launches the benchmark function. It gradually increases the number
// of benchmark iterations until the benchmark runs for the requested benchtime.
// launch is run by the doBench function as a separate goroutine.
// run1 must have been called on b.
func (b *B) launch() <span class="cov8" title="1">{
        // Signal that we're done whether we return normally
        // or by FailNow's runtime.Goexit.
        defer func() </span><span class="cov8" title="1">{
                b.signal &lt;- true
        }</span>()

        // Run the benchmark for at least the specified amount of time.
        <span class="cov8" title="1">if b.benchTime.n &gt; 0 </span><span class="cov0" title="0">{
                // We already ran a single iteration in run1.
                // If -benchtime=1x was requested, use that result.
                // See https://golang.org/issue/32051.
                if b.benchTime.n &gt; 1 </span><span class="cov0" title="0">{
                        b.runN(b.benchTime.n)
                }</span>
        } else<span class="cov8" title="1"> {
                d := b.benchTime.d
                for n := int64(1); !b.failed &amp;&amp; b.duration &lt; d &amp;&amp; n &lt; 1e9; </span><span class="cov8" title="1">{
                        last := n
                        // Predict required iterations.
                        goalns := d.Nanoseconds()
                        prevIters := int64(b.N)
                        prevns := b.duration.Nanoseconds()
                        if prevns &lt;= 0 </span><span class="cov0" title="0">{
                                // Round up, to avoid div by zero.
                                prevns = 1
                        }</span>
                        // Order of operations matters.
                        // For very fast benchmarks, prevIters ~= prevns.
                        // If you divide first, you get 0 or 1,
                        // which can hide an order of magnitude in execution time.
                        // So multiply first, then divide.
                        <span class="cov8" title="1">n = goalns * prevIters / prevns
                        // Run more iterations than we think we'll need (1.2x).
                        n += n / 5
                        // Don't grow too fast in case we had timing errors previously.
                        n = min(n, 100*last)
                        // Be sure to run at least one more than last time.
                        n = max(n, last+1)
                        // Don't run more than 1e9 times. (This also keeps n in int range on 32 bit platforms.)
                        n = min(n, 1e9)
                        b.runN(int(n))</span>
                }
        }
        <span class="cov8" title="1">b.result = BenchmarkResult{b.N, b.duration, b.bytes, b.netAllocs, b.netBytes, b.extra}</span>
}

// ReportMetric adds "n unit" to the reported benchmark results.
// If the metric is per-iteration, the caller should divide by b.N,
// and by convention units should end in "/op".
// ReportMetric overrides any previously reported value for the same unit.
// ReportMetric panics if unit is the empty string or if unit contains
// any whitespace.
// If unit is a unit normally reported by the benchmark framework itself
// (such as "allocs/op"), ReportMetric will override that metric.
// Setting "ns/op" to 0 will suppress that built-in metric.
func (b *B) ReportMetric(n float64, unit string) <span class="cov8" title="1">{
        if unit == "" </span><span class="cov0" title="0">{
                panic("metric unit must not be empty")</span>
        }
        <span class="cov8" title="1">if strings.IndexFunc(unit, unicode.IsSpace) &gt;= 0 </span><span class="cov0" title="0">{
                panic("metric unit must not contain whitespace")</span>
        }
        <span class="cov8" title="1">b.extra[unit] = n</span>
}

// BenchmarkResult contains the results of a benchmark run.
type BenchmarkResult struct {
        N         int           // The number of iterations.
        T         time.Duration // The total time taken.
        Bytes     int64         // Bytes processed in one iteration.
        MemAllocs uint64        // The total number of memory allocations.
        MemBytes  uint64        // The total number of bytes allocated.

        // Extra records additional metrics reported by ReportMetric.
        Extra map[string]float64
}

// NsPerOp returns the "ns/op" metric.
func (r BenchmarkResult) NsPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["ns/op"]; ok </span><span class="cov8" title="1">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return r.T.Nanoseconds() / int64(r.N)</span>
}

// mbPerSec returns the "MB/s" metric.
func (r BenchmarkResult) mbPerSec() float64 <span class="cov8" title="1">{
        if v, ok := r.Extra["MB/s"]; ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">if r.Bytes &lt;= 0 || r.T &lt;= 0 || r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov0" title="0">return (float64(r.Bytes) * float64(r.N) / 1e6) / r.T.Seconds()</span>
}

// AllocsPerOp returns the "allocs/op" metric,
// which is calculated as r.MemAllocs / r.N.
func (r BenchmarkResult) AllocsPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["allocs/op"]; ok </span><span class="cov0" title="0">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return int64(r.MemAllocs) / int64(r.N)</span>
}

// AllocedBytesPerOp returns the "B/op" metric,
// which is calculated as r.MemBytes / r.N.
func (r BenchmarkResult) AllocedBytesPerOp() int64 <span class="cov8" title="1">{
        if v, ok := r.Extra["B/op"]; ok </span><span class="cov0" title="0">{
                return int64(v)
        }</span>
        <span class="cov8" title="1">if r.N &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return int64(r.MemBytes) / int64(r.N)</span>
}

// String returns a summary of the benchmark results.
// It follows the benchmark result line format from
// https://golang.org/design/14313-benchmark-format, not including the
// benchmark name.
// Extra metrics override built-in metrics of the same name.
// String does not include allocs/op or B/op, since those are reported
// by MemString.
func (r BenchmarkResult) String() string <span class="cov8" title="1">{
        buf := new(strings.Builder)
        fmt.Fprintf(buf, "%8d", r.N)

        // Get ns/op as a float.
        ns, ok := r.Extra["ns/op"]
        if !ok </span><span class="cov8" title="1">{
                ns = float64(r.T.Nanoseconds()) / float64(r.N)
        }</span>
        <span class="cov8" title="1">if ns != 0 </span><span class="cov8" title="1">{
                buf.WriteByte('\t')
                prettyPrint(buf, ns, "ns/op")
        }</span>

        <span class="cov8" title="1">if mbs := r.mbPerSec(); mbs != 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(buf, "\t%7.2f MB/s", mbs)
        }</span>

        // Print extra metrics that aren't represented in the standard
        // metrics.
        <span class="cov8" title="1">var extraKeys []string
        for k := range r.Extra </span><span class="cov8" title="1">{
                switch k </span>{
                case "ns/op", "MB/s", "B/op", "allocs/op":<span class="cov8" title="1">
                        // Built-in metrics reported elsewhere.
                        continue</span>
                }
                <span class="cov8" title="1">extraKeys = append(extraKeys, k)</span>
        }
        <span class="cov8" title="1">sort.Strings(extraKeys)
        for _, k := range extraKeys </span><span class="cov8" title="1">{
                buf.WriteByte('\t')
                prettyPrint(buf, r.Extra[k], k)
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

func prettyPrint(w io.Writer, x float64, unit string) <span class="cov8" title="1">{
        // Print all numbers with 10 places before the decimal point
        // and small numbers with four sig figs. Field widths are
        // chosen to fit the whole part in 10 places while aligning
        // the decimal point of all fractional formats.
        var format string
        switch y := math.Abs(x); </span>{
        case y == 0 || y &gt;= 999.95:<span class="cov8" title="1">
                format = "%10.0f %s"</span>
        case y &gt;= 99.995:<span class="cov8" title="1">
                format = "%12.1f %s"</span>
        case y &gt;= 9.9995:<span class="cov8" title="1">
                format = "%13.2f %s"</span>
        case y &gt;= 0.99995:<span class="cov8" title="1">
                format = "%14.3f %s"</span>
        case y &gt;= 0.099995:<span class="cov8" title="1">
                format = "%15.4f %s"</span>
        case y &gt;= 0.0099995:<span class="cov0" title="0">
                format = "%16.5f %s"</span>
        case y &gt;= 0.00099995:<span class="cov8" title="1">
                format = "%17.6f %s"</span>
        default:<span class="cov8" title="1">
                format = "%18.7f %s"</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(w, format, x, unit)</span>
}

// MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.
func (r BenchmarkResult) MemString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%8d B/op\t%8d allocs/op",
                r.AllocedBytesPerOp(), r.AllocsPerOp())
}</span>

// benchmarkName returns full name of benchmark including procs suffix.
func benchmarkName(name string, n int) string <span class="cov0" title="0">{
        if n != 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s-%d", name, n)
        }</span>
        <span class="cov0" title="0">return name</span>
}

type benchContext struct {
        match *matcher

        maxLen int // The largest recorded benchmark name.
        extLen int // Maximum extension length.
}

// RunBenchmarks is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) <span class="cov0" title="0">{
        runBenchmarks("", matchString, benchmarks)
}</span>

func runBenchmarks(importPath string, matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) bool <span class="cov8" title="1">{
        // If no flag was specified, don't run benchmarks.
        if len(*matchBenchmarks) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        // Collect matching benchmarks and determine longest name.
        <span class="cov0" title="0">maxprocs := 1
        for _, procs := range cpuList </span><span class="cov0" title="0">{
                if procs &gt; maxprocs </span><span class="cov0" title="0">{
                        maxprocs = procs
                }</span>
        }
        <span class="cov0" title="0">ctx := &amp;benchContext{
                match:  newMatcher(matchString, *matchBenchmarks, "-test.bench"),
                extLen: len(benchmarkName("", maxprocs)),
        }
        var bs []InternalBenchmark
        for _, Benchmark := range benchmarks </span><span class="cov0" title="0">{
                if _, matched, _ := ctx.match.fullName(nil, Benchmark.Name); matched </span><span class="cov0" title="0">{
                        bs = append(bs, Benchmark)
                        benchName := benchmarkName(Benchmark.Name, maxprocs)
                        if l := len(benchName) + ctx.extLen + 1; l &gt; ctx.maxLen </span><span class="cov0" title="0">{
                                ctx.maxLen = l
                        }</span>
                }
        }
        <span class="cov0" title="0">main := &amp;B{
                common: common{
                        name:  "Main",
                        w:     os.Stdout,
                        bench: true,
                },
                importPath: importPath,
                benchFunc: func(b *B) </span><span class="cov0" title="0">{
                        for _, Benchmark := range bs </span><span class="cov0" title="0">{
                                b.Run(Benchmark.Name, Benchmark.F)
                        }</span>
                },
                benchTime: benchTime,
                context:   ctx,
        }
        <span class="cov0" title="0">if Verbose() </span><span class="cov0" title="0">{
                main.chatty = newChattyPrinter(main.w)
        }</span>
        <span class="cov0" title="0">main.runN(1)
        return !main.failed</span>
}

// processBench runs bench b for the configured CPU counts and prints the results.
func (ctx *benchContext) processBench(b *B) <span class="cov0" title="0">{
        for i, procs := range cpuList </span><span class="cov0" title="0">{
                for j := uint(0); j &lt; *count; j++ </span><span class="cov0" title="0">{
                        runtime.GOMAXPROCS(procs)
                        benchName := benchmarkName(b.name, procs)

                        // If it's chatty, we've already printed this information.
                        if b.chatty == nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(b.w, "%-*s\t", ctx.maxLen, benchName)
                        }</span>
                        // Recompute the running time for all but the first iteration.
                        <span class="cov0" title="0">if i &gt; 0 || j &gt; 0 </span><span class="cov0" title="0">{
                                b = &amp;B{
                                        common: common{
                                                signal: make(chan bool),
                                                name:   b.name,
                                                w:      b.w,
                                                chatty: b.chatty,
                                                bench:  true,
                                        },
                                        benchFunc: b.benchFunc,
                                        benchTime: b.benchTime,
                                }
                                b.run1()
                        }</span>
                        <span class="cov0" title="0">r := b.doBench()
                        if b.failed </span><span class="cov0" title="0">{
                                // The output could be very long here, but probably isn't.
                                // We print it all, regardless, because we don't want to trim the reason
                                // the benchmark failed.
                                fmt.Fprintf(b.w, "--- FAIL: %s\n%s", benchName, b.output)
                                continue</span>
                        }
                        <span class="cov0" title="0">results := r.String()
                        if b.chatty != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(b.w, "%-*s\t", ctx.maxLen, benchName)
                        }</span>
                        <span class="cov0" title="0">if *benchmarkMemory || b.showAllocResult </span><span class="cov0" title="0">{
                                results += "\t" + r.MemString()
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(b.w, results)
                        // Unlike with tests, we ignore the -chatty flag and always print output for
                        // benchmarks since the output generation time will skew the results.
                        if len(b.output) &gt; 0 </span><span class="cov0" title="0">{
                                b.trimOutput()
                                fmt.Fprintf(b.w, "--- BENCH: %s\n%s", benchName, b.output)
                        }</span>
                        <span class="cov0" title="0">if p := runtime.GOMAXPROCS(-1); p != procs </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "testing: %s left GOMAXPROCS set to %d\n", benchName, p)
                        }</span>
                }
        }
}

// Run benchmarks f as a subbenchmark with the given name. It reports
// whether there were any failures.
//
// A subbenchmark is like any other benchmark. A benchmark that calls Run at
// least once will not be measured itself and will be called once with N=1.
func (b *B) Run(name string, f func(b *B)) bool <span class="cov8" title="1">{
        // Since b has subbenchmarks, we will no longer run it as a benchmark itself.
        // Release the lock and acquire it on exit to ensure locks stay paired.
        atomic.StoreInt32(&amp;b.hasSub, 1)
        benchmarkLock.Unlock()
        defer benchmarkLock.Lock()

        benchName, ok, partial := b.name, true, false
        if b.context != nil </span><span class="cov0" title="0">{
                benchName, ok, partial = b.context.match.fullName(&amp;b.common, name)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        n := runtime.Callers(2, pc[:])
        sub := &amp;B{
                common: common{
                        signal:  make(chan bool),
                        name:    benchName,
                        parent:  &amp;b.common,
                        level:   b.level + 1,
                        creator: pc[:n],
                        w:       b.w,
                        chatty:  b.chatty,
                        bench:   true,
                },
                importPath: b.importPath,
                benchFunc:  f,
                benchTime:  b.benchTime,
                context:    b.context,
        }
        if partial </span><span class="cov0" title="0">{
                // Partial name match, like -bench=X/Y matching BenchmarkX.
                // Only process sub-benchmarks, if any.
                atomic.StoreInt32(&amp;sub.hasSub, 1)
        }</span>

        <span class="cov8" title="1">if b.chatty != nil </span><span class="cov8" title="1">{
                labelsOnce.Do(func() </span><span class="cov0" title="0">{
                        fmt.Printf("goos: %s\n", runtime.GOOS)
                        fmt.Printf("goarch: %s\n", runtime.GOARCH)
                        if b.importPath != "" </span><span class="cov0" title="0">{
                                fmt.Printf("pkg: %s\n", b.importPath)
                        }</span>
                        <span class="cov0" title="0">if cpu := sysinfo.CPU.Name(); cpu != "" </span><span class="cov0" title="0">{
                                fmt.Printf("cpu: %s\n", cpu)
                        }</span>
                })

                <span class="cov8" title="1">fmt.Println(benchName)</span>
        }

        <span class="cov8" title="1">if sub.run1() </span><span class="cov8" title="1">{
                sub.run()
        }</span>
        <span class="cov8" title="1">b.add(sub.result)
        return !sub.failed</span>
}

// add simulates running benchmarks in sequence in a single iteration. It is
// used to give some meaningful results in case func Benchmark is used in
// combination with Run.
func (b *B) add(other BenchmarkResult) <span class="cov8" title="1">{
        r := &amp;b.result
        // The aggregated BenchmarkResults resemble running all subbenchmarks as
        // in sequence in a single benchmark.
        r.N = 1
        r.T += time.Duration(other.NsPerOp())
        if other.Bytes == 0 </span><span class="cov8" title="1">{
                // Summing Bytes is meaningless in aggregate if not all subbenchmarks
                // set it.
                b.missingBytes = true
                r.Bytes = 0
        }</span>
        <span class="cov8" title="1">if !b.missingBytes </span><span class="cov8" title="1">{
                r.Bytes += other.Bytes
        }</span>
        <span class="cov8" title="1">r.MemAllocs += uint64(other.AllocsPerOp())
        r.MemBytes += uint64(other.AllocedBytesPerOp())</span>
}

// trimOutput shortens the output from a benchmark, which can be very long.
func (b *B) trimOutput() <span class="cov8" title="1">{
        // The output is likely to appear multiple times because the benchmark
        // is run multiple times, but at least it will be seen. This is not a big deal
        // because benchmarks rarely print, but just in case, we trim it if it's too long.
        const maxNewlines = 10
        for nlCount, j := 0, 0; j &lt; len(b.output); j++ </span><span class="cov0" title="0">{
                if b.output[j] == '\n' </span><span class="cov0" title="0">{
                        nlCount++
                        if nlCount &gt;= maxNewlines </span><span class="cov0" title="0">{
                                b.output = append(b.output[:j], "\n\t... [output truncated]\n"...)
                                break</span>
                        }
                }
        }
}

// A PB is used by RunParallel for running parallel benchmarks.
type PB struct {
        globalN *uint64 // shared between all worker goroutines iteration counter
        grain   uint64  // acquire that many iterations from globalN at once
        cache   uint64  // local cache of acquired iterations
        bN      uint64  // total number of iterations to execute (b.N)
}

// Next reports whether there are more iterations to execute.
func (pb *PB) Next() bool <span class="cov8" title="1">{
        if pb.cache == 0 </span><span class="cov8" title="1">{
                n := atomic.AddUint64(pb.globalN, pb.grain)
                if n &lt;= pb.bN </span><span class="cov8" title="1">{
                        pb.cache = pb.grain
                }</span> else<span class="cov8" title="1"> if n &lt; pb.bN+pb.grain </span><span class="cov8" title="1">{
                        pb.cache = pb.bN + pb.grain - n
                }</span> else<span class="cov8" title="1"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">pb.cache--
        return true</span>
}

// RunParallel runs a benchmark in parallel.
// It creates multiple goroutines and distributes b.N iterations among them.
// The number of goroutines defaults to GOMAXPROCS. To increase parallelism for
// non-CPU-bound benchmarks, call SetParallelism before RunParallel.
// RunParallel is usually used with the go test -cpu flag.
//
// The body function will be run in each goroutine. It should set up any
// goroutine-local state and then iterate until pb.Next returns false.
// It should not use the StartTimer, StopTimer, or ResetTimer functions,
// because they have global effect. It should also not call Run.
func (b *B) RunParallel(body func(*PB)) <span class="cov8" title="1">{
        if b.N == 0 </span><span class="cov0" title="0">{
                return // Nothing to do when probing.
        }</span>
        // Calculate grain size as number of iterations that take ~100µs.
        // 100µs is enough to amortize the overhead and provide sufficient
        // dynamic load balancing.
        <span class="cov8" title="1">grain := uint64(0)
        if b.previousN &gt; 0 &amp;&amp; b.previousDuration &gt; 0 </span><span class="cov8" title="1">{
                grain = 1e5 * uint64(b.previousN) / uint64(b.previousDuration)
        }</span>
        <span class="cov8" title="1">if grain &lt; 1 </span><span class="cov8" title="1">{
                grain = 1
        }</span>
        // We expect the inner loop and function call to take at least 10ns,
        // so do not do more than 100µs/10ns=1e4 iterations.
        <span class="cov8" title="1">if grain &gt; 1e4 </span><span class="cov0" title="0">{
                grain = 1e4
        }</span>

        <span class="cov8" title="1">n := uint64(0)
        numProcs := b.parallelism * runtime.GOMAXPROCS(0)
        var wg sync.WaitGroup
        wg.Add(numProcs)
        for p := 0; p &lt; numProcs; p++ </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        pb := &amp;PB{
                                globalN: &amp;n,
                                grain:   grain,
                                bN:      uint64(b.N),
                        }
                        body(pb)
                }</span>()
        }
        <span class="cov8" title="1">wg.Wait()
        if n &lt;= uint64(b.N) &amp;&amp; !b.Failed() </span><span class="cov8" title="1">{
                b.Fatal("RunParallel: body exited without pb.Next() == false")
        }</span>
}

// SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS.
// There is usually no need to call SetParallelism for CPU-bound benchmarks.
// If p is less than 1, this call will have no effect.
func (b *B) SetParallelism(p int) <span class="cov8" title="1">{
        if p &gt;= 1 </span><span class="cov8" title="1">{
                b.parallelism = p
        }</span>
}

// Benchmark benchmarks a single function. It is useful for creating
// custom benchmarks that do not use the "go test" command.
//
// If f depends on testing flags, then Init must be used to register
// those flags before calling Benchmark and before calling flag.Parse.
//
// If f calls Run, the result will be an estimate of running all its
// subbenchmarks that don't call Run in sequence in a single benchmark.
func Benchmark(f func(b *B)) BenchmarkResult <span class="cov8" title="1">{
        b := &amp;B{
                common: common{
                        signal: make(chan bool),
                        w:      discard{},
                },
                benchFunc: f,
                benchTime: benchTime,
        }
        if b.run1() </span><span class="cov8" title="1">{
                b.run()
        }</span>
        <span class="cov8" title="1">return b.result</span>
}

type discard struct{}

func (discard) Write(b []byte) (n int, err error) <span class="cov8" title="1">{ return len(b), nil }</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Support for test coverage.

package testing

import (
        "fmt"
        "os"
        "sync/atomic"
)

// CoverBlock records the coverage data for a single basic block.
// The fields are 1-indexed, as in an editor: The opening line of
// the file is number 1, for example. Columns are measured
// in bytes.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
type CoverBlock struct {
        Line0 uint32 // Line number for block start.
        Col0  uint16 // Column number for block start.
        Line1 uint32 // Line number for block end.
        Col1  uint16 // Column number for block end.
        Stmts uint16 // Number of statements included in this block.
}

var cover Cover

// Cover records information about test coverage checking.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
type Cover struct {
        Mode            string
        Counters        map[string][]uint32
        Blocks          map[string][]CoverBlock
        CoveredPackages string
}

// Coverage reports the current code coverage as a fraction in the range [0, 1].
// If coverage is not enabled, Coverage returns 0.
//
// When running a large set of sequential test cases, checking Coverage after each one
// can be useful for identifying which test cases exercise new code paths.
// It is not a replacement for the reports generated by 'go test -cover' and
// 'go tool cover'.
func Coverage() float64 <span class="cov0" title="0">{
        var n, d int64
        for _, counters := range cover.Counters </span><span class="cov0" title="0">{
                for i := range counters </span><span class="cov0" title="0">{
                        if atomic.LoadUint32(&amp;counters[i]) &gt; 0 </span><span class="cov0" title="0">{
                                n++
                        }</span>
                        <span class="cov0" title="0">d++</span>
                }
        }
        <span class="cov0" title="0">if d == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(n) / float64(d)</span>
}

// RegisterCover records the coverage data accumulators for the tests.
// NOTE: This function is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
func RegisterCover(c Cover) <span class="cov8" title="1">{
        cover = c
}</span>

// mustBeNil checks the error and, if present, reports it and exits.
func mustBeNil(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                os.Exit(2)
        }</span>
}

// coverReport reports the coverage percentage and writes a coverage profile if requested.
func coverReport() <span class="cov8" title="1">{
        var f *os.File
        var err error
        if *coverProfile != "" </span><span class="cov8" title="1">{
                f, err = os.Create(toOutputDir(*coverProfile))
                mustBeNil(err)
                fmt.Fprintf(f, "mode: %s\n", cover.Mode)
                defer func() </span><span class="cov0" title="0">{ mustBeNil(f.Close()) }</span>()
        }

        <span class="cov8" title="1">var active, total int64
        var count uint32
        for name, counts := range cover.Counters </span><span class="cov8" title="1">{
                blocks := cover.Blocks[name]
                for i := range counts </span><span class="cov8" title="1">{
                        stmts := int64(blocks[i].Stmts)
                        total += stmts
                        count = atomic.LoadUint32(&amp;counts[i]) // For -mode=atomic.
                        if count &gt; 0 </span><span class="cov8" title="1">{
                                active += stmts
                        }</span>
                        <span class="cov8" title="1">if f != nil </span><span class="cov8" title="1">{
                                _, err := fmt.Fprintf(f, "%s:%d.%d,%d.%d %d %d\n", name,
                                        blocks[i].Line0, blocks[i].Col0,
                                        blocks[i].Line1, blocks[i].Col1,
                                        stmts,
                                        count)
                                mustBeNil(err)
                        }</span>
                }
        }
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                fmt.Println("coverage: [no statements]")
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("coverage: %.1f%% of statements%s\n", 100*float64(active)/float64(total), cover.CoveredPackages)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "fmt"
        "os"
        "sort"
        "strings"
        "time"
)

type InternalExample struct {
        Name      string
        F         func()
        Output    string
        Unordered bool
}

// RunExamples is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool) <span class="cov0" title="0">{
        _, ok = runExamples(matchString, examples)
        return ok
}</span>

func runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool) <span class="cov8" title="1">{
        ok = true

        var eg InternalExample

        for _, eg = range examples </span><span class="cov0" title="0">{
                matched, err := matchString(*match, eg.Name)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: invalid regexp for -test.run: %s\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if !matched </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ran = true
                if !runExample(eg) </span><span class="cov0" title="0">{
                        ok = false
                }</span>
        }

        <span class="cov8" title="1">return ran, ok</span>
}

func sortLines(output string) string <span class="cov0" title="0">{
        lines := strings.Split(output, "\n")
        sort.Strings(lines)
        return strings.Join(lines, "\n")
}</span>

// processRunResult computes a summary and status of the result of running an example test.
// stdout is the captured output from stdout of the test.
// recovered is the result of invoking recover after running the test, in case it panicked.
//
// If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
// If the test is chatty/verbose, it'll print a success message to stdout.
// If recovered is non-nil, it'll panic with that value.
// If the test panicked with nil, or invoked runtime.Goexit, it'll be
// made to fail and panic with errNilPanicOrGoexit
func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered any) (passed bool) <span class="cov0" title="0">{
        passed = true
        dstr := fmtDuration(timeSpent)
        var fail string
        got := strings.TrimSpace(stdout)
        want := strings.TrimSpace(eg.Output)
        if eg.Unordered </span><span class="cov0" title="0">{
                if sortLines(got) != sortLines(want) &amp;&amp; recovered == nil </span><span class="cov0" title="0">{
                        fail = fmt.Sprintf("got:\n%s\nwant (unordered):\n%s\n", stdout, eg.Output)
                }</span>
        } else<span class="cov0" title="0"> {
                if got != want &amp;&amp; recovered == nil </span><span class="cov0" title="0">{
                        fail = fmt.Sprintf("got:\n%s\nwant:\n%s\n", got, want)
                }</span>
        }
        <span class="cov0" title="0">if fail != "" || !finished || recovered != nil </span><span class="cov0" title="0">{
                fmt.Printf("--- FAIL: %s (%s)\n%s", eg.Name, dstr, fail)
                passed = false
        }</span> else<span class="cov0" title="0"> if *chatty </span><span class="cov0" title="0">{
                fmt.Printf("--- PASS: %s (%s)\n", eg.Name, dstr)
        }</span>

        <span class="cov0" title="0">if recovered != nil </span><span class="cov0" title="0">{
                // Propagate the previously recovered result, by panicking.
                panic(recovered)</span>
        }
        <span class="cov0" title="0">if !finished &amp;&amp; recovered == nil </span><span class="cov0" title="0">{
                panic(errNilPanicOrGoexit)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "bytes"
        "errors"
        "flag"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "reflect"
        "runtime"
        "sync/atomic"
        "time"
)

func initFuzzFlags() <span class="cov8" title="1">{
        matchFuzz = flag.String("test.fuzz", "", "run the fuzz test matching `regexp`")
        flag.Var(&amp;fuzzDuration, "test.fuzztime", "time to spend fuzzing; default is to run indefinitely")
        flag.Var(&amp;minimizeDuration, "test.fuzzminimizetime", "time to spend minimizing a value after finding a failing input")

        fuzzCacheDir = flag.String("test.fuzzcachedir", "", "directory where interesting fuzzing inputs are stored (for use only by cmd/go)")
        isFuzzWorker = flag.Bool("test.fuzzworker", false, "coordinate with the parent process to fuzz random values (for use only by cmd/go)")
}</span>

var (
        matchFuzz        *string
        fuzzDuration     durationOrCountFlag
        minimizeDuration = durationOrCountFlag{d: 60 * time.Second, allowZero: true}
        fuzzCacheDir     *string
        isFuzzWorker     *bool

        // corpusDir is the parent directory of the fuzz test's seed corpus within
        // the package.
        corpusDir = "testdata/fuzz"
)

// fuzzWorkerExitCode is used as an exit code by fuzz worker processes after an
// internal error. This distinguishes internal errors from uncontrolled panics
// and other failiures. Keep in sync with internal/fuzz.workerExitCode.
const fuzzWorkerExitCode = 70

// InternalFuzzTarget is an internal type but exported because it is
// cross-package; it is part of the implementation of the "go test" command.
type InternalFuzzTarget struct {
        Name string
        Fn   func(f *F)
}

// F is a type passed to fuzz tests.
//
// Fuzz tests run generated inputs against a provided fuzz target, which can
// find and report potential bugs in the code being tested.
//
// A fuzz test runs the seed corpus by default, which includes entries provided
// by (*F).Add and entries in the testdata/fuzz/&lt;FuzzTestName&gt; directory. After
// any necessary setup and calls to (*F).Add, the fuzz test must then call
// (*F).Fuzz to provide the fuzz target. See the testing package documentation
// for an example, and see the F.Fuzz and F.Add method documentation for
// details.
//
// *F methods can only be called before (*F).Fuzz. Once the test is
// executing the fuzz target, only (*T) methods can be used. The only *F methods
// that are allowed in the (*F).Fuzz function are (*F).Failed and (*F).Name.
type F struct {
        common
        fuzzContext *fuzzContext
        testContext *testContext

        // inFuzzFn is true when the fuzz function is running. Most F methods cannot
        // be called when inFuzzFn is true.
        inFuzzFn bool

        // corpus is a set of seed corpus entries, added with F.Add and loaded
        // from testdata.
        corpus []corpusEntry

        result     fuzzResult
        fuzzCalled bool
}

var _ TB = (*F)(nil)

// corpusEntry is an alias to the same type as internal/fuzz.CorpusEntry.
// We use a type alias because we don't want to export this type, and we can't
// import internal/fuzz from testing.
type corpusEntry = struct {
        Parent     string
        Path       string
        Data       []byte
        Values     []any
        Generation int
        IsSeed     bool
}

// Helper marks the calling function as a test helper function.
// When printing file and line information, that function will be skipped.
// Helper may be called simultaneously from multiple goroutines.
func (f *F) Helper() <span class="cov8" title="1">{
        if f.inFuzzFn </span><span class="cov0" title="0">{
                panic("testing: f.Helper was called inside the fuzz target, use t.Helper instead")</span>
        }

        // common.Helper is inlined here.
        // If we called it, it would mark F.Helper as the helper
        // instead of the caller.
        <span class="cov8" title="1">f.mu.Lock()
        defer f.mu.Unlock()
        if f.helperPCs == nil </span><span class="cov8" title="1">{
                f.helperPCs = make(map[uintptr]struct{})
        }</span>
        // repeating code from callerName here to save walking a stack frame
        <span class="cov8" title="1">var pc [1]uintptr
        n := runtime.Callers(2, pc[:]) // skip runtime.Callers + Helper
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">if _, found := f.helperPCs[pc[0]]; !found </span><span class="cov8" title="1">{
                f.helperPCs[pc[0]] = struct{}{}
                f.helperNames = nil // map will be recreated next time it is needed
        }</span>
}

// Fail marks the function as having failed but continues execution.
func (f *F) Fail() <span class="cov0" title="0">{
        // (*F).Fail may be called by (*T).Fail, which we should allow. However, we
        // shouldn't allow direct (*F).Fail calls from inside the (*F).Fuzz function.
        if f.inFuzzFn </span><span class="cov0" title="0">{
                panic("testing: f.Fail was called inside the fuzz target, use t.Fail instead")</span>
        }
        <span class="cov0" title="0">f.common.Helper()
        f.common.Fail()</span>
}

// Skipped reports whether the test was skipped.
func (f *F) Skipped() bool <span class="cov0" title="0">{
        // (*F).Skipped may be called by tRunner, which we should allow. However, we
        // shouldn't allow direct (*F).Skipped calls from inside the (*F).Fuzz function.
        if f.inFuzzFn </span><span class="cov0" title="0">{
                panic("testing: f.Skipped was called inside the fuzz target, use t.Skipped instead")</span>
        }
        <span class="cov0" title="0">f.common.Helper()
        return f.common.Skipped()</span>
}

// Add will add the arguments to the seed corpus for the fuzz test. This will be
// a no-op if called after or within the fuzz target, and args must match the
// arguments for the fuzz target.
func (f *F) Add(args ...any) <span class="cov8" title="1">{
        var values []any
        for i := range args </span><span class="cov8" title="1">{
                if t := reflect.TypeOf(args[i]); !supportedTypes[t] </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("testing: unsupported type to Add %v", t))</span>
                }
                <span class="cov8" title="1">values = append(values, args[i])</span>
        }
        <span class="cov8" title="1">f.corpus = append(f.corpus, corpusEntry{Values: values, IsSeed: true, Path: fmt.Sprintf("seed#%d", len(f.corpus))})</span>
}

// supportedTypes represents all of the supported types which can be fuzzed.
var supportedTypes = map[reflect.Type]bool{
        reflect.TypeOf(([]byte)("")):  true,
        reflect.TypeOf((string)("")):  true,
        reflect.TypeOf((bool)(false)): true,
        reflect.TypeOf((byte)(0)):     true,
        reflect.TypeOf((rune)(0)):     true,
        reflect.TypeOf((float32)(0)):  true,
        reflect.TypeOf((float64)(0)):  true,
        reflect.TypeOf((int)(0)):      true,
        reflect.TypeOf((int8)(0)):     true,
        reflect.TypeOf((int16)(0)):    true,
        reflect.TypeOf((int32)(0)):    true,
        reflect.TypeOf((int64)(0)):    true,
        reflect.TypeOf((uint)(0)):     true,
        reflect.TypeOf((uint8)(0)):    true,
        reflect.TypeOf((uint16)(0)):   true,
        reflect.TypeOf((uint32)(0)):   true,
        reflect.TypeOf((uint64)(0)):   true,
}

// Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of
// arguments, those arguments will be added to the seed corpus.
//
// ff must be a function with no return value whose first argument is *T and
// whose remaining arguments are the types to be fuzzed.
// For example:
//
//        f.Fuzz(func(t *testing.T, b []byte, i int) { ... })
//
// The following types are allowed: []byte, string, bool, byte, rune, float32,
// float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64.
// More types may be supported in the future.
//
// ff must not call any *F methods, e.g. (*F).Log, (*F).Error, (*F).Skip. Use
// the corresponding *T method instead. The only *F methods that are allowed in
// the (*F).Fuzz function are (*F).Failed and (*F).Name.
//
// This function should be fast and deterministic, and its behavior should not
// depend on shared state. No mutatable input arguments, or pointers to them,
// should be retained between executions of the fuzz function, as the memory
// backing them may be mutated during a subsequent invocation. ff must not
// modify the underlying data of the arguments provided by the fuzzing engine.
//
// When fuzzing, F.Fuzz does not return until a problem is found, time runs out
// (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz
// should be called exactly once, unless F.Skip or F.Fail is called beforehand.
func (f *F) Fuzz(ff any) <span class="cov8" title="1">{
        if f.fuzzCalled </span><span class="cov0" title="0">{
                panic("testing: F.Fuzz called more than once")</span>
        }
        <span class="cov8" title="1">f.fuzzCalled = true
        if f.failed </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">f.Helper()

        // ff should be in the form func(*testing.T, ...interface{})
        fn := reflect.ValueOf(ff)
        fnType := fn.Type()
        if fnType.Kind() != reflect.Func </span><span class="cov0" title="0">{
                panic("testing: F.Fuzz must receive a function")</span>
        }
        <span class="cov8" title="1">if fnType.NumIn() &lt; 2 || fnType.In(0) != reflect.TypeOf((*T)(nil)) </span><span class="cov0" title="0">{
                panic("testing: fuzz target must receive at least two arguments, where the first argument is a *T")</span>
        }
        <span class="cov8" title="1">if fnType.NumOut() != 0 </span><span class="cov0" title="0">{
                panic("testing: fuzz target must not return a value")</span>
        }

        // Save the types of the function to compare against the corpus.
        <span class="cov8" title="1">var types []reflect.Type
        for i := 1; i &lt; fnType.NumIn(); i++ </span><span class="cov8" title="1">{
                t := fnType.In(i)
                if !supportedTypes[t] </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("testing: unsupported type for fuzzing %v", t))</span>
                }
                <span class="cov8" title="1">types = append(types, t)</span>
        }

        // Load the testdata seed corpus. Check types of entries in the testdata
        // corpus and entries declared with F.Add.
        //
        // Don't load the seed corpus if this is a worker process; we won't use it.
        <span class="cov8" title="1">if f.fuzzContext.mode != fuzzWorker </span><span class="cov8" title="1">{
                for _, c := range f.corpus </span><span class="cov8" title="1">{
                        if err := f.fuzzContext.deps.CheckCorpus(c.Values, types); err != nil </span><span class="cov0" title="0">{
                                // TODO(#48302): Report the source location of the F.Add call.
                                f.Fatal(err)
                        }</span>
                }

                // Load seed corpus
                <span class="cov8" title="1">c, err := f.fuzzContext.deps.ReadCorpus(filepath.Join(corpusDir, f.name), types)
                if err != nil </span><span class="cov0" title="0">{
                        f.Fatal(err)
                }</span>
                <span class="cov8" title="1">for i := range c </span><span class="cov0" title="0">{
                        c[i].IsSeed = true // these are all seed corpus values
                        if f.fuzzContext.mode == fuzzCoordinator </span><span class="cov0" title="0">{
                                // If this is the coordinator process, zero the values, since we don't need
                                // to hold onto them.
                                c[i].Values = nil
                        }</span>
                }

                <span class="cov8" title="1">f.corpus = append(f.corpus, c...)</span>
        }

        // run calls fn on a given input, as a subtest with its own T.
        // run is analogous to T.Run. The test filtering and cleanup works similarly.
        // fn is called in its own goroutine.
        <span class="cov8" title="1">run := func(captureOut io.Writer, e corpusEntry) (ok bool) </span><span class="cov8" title="1">{
                if e.Values == nil </span><span class="cov0" title="0">{
                        // The corpusEntry must have non-nil Values in order to run the
                        // test. If Values is nil, it is a bug in our code.
                        panic(fmt.Sprintf("corpus file %q was not unmarshaled", e.Path))</span>
                }
                <span class="cov8" title="1">if shouldFailFast() </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">testName := f.name
                if e.Path != "" </span><span class="cov8" title="1">{
                        testName = fmt.Sprintf("%s/%s", testName, filepath.Base(e.Path))
                }</span>
                <span class="cov8" title="1">if f.testContext.isFuzzing </span><span class="cov0" title="0">{
                        // Don't preserve subtest names while fuzzing. If fn calls T.Run,
                        // there will be a very large number of subtests with duplicate names,
                        // which will use a large amount of memory. The subtest names aren't
                        // useful since there's no way to re-run them deterministically.
                        f.testContext.match.clearSubNames()
                }</span>

                // Record the stack trace at the point of this call so that if the subtest
                // function - which runs in a separate stack - is marked as a helper, we can
                // continue walking the stack into the parent test.
                <span class="cov8" title="1">var pc [maxStackLen]uintptr
                n := runtime.Callers(2, pc[:])
                t := &amp;T{
                        common: common{
                                barrier: make(chan bool),
                                signal:  make(chan bool),
                                name:    testName,
                                parent:  &amp;f.common,
                                level:   f.level + 1,
                                creator: pc[:n],
                                chatty:  f.chatty,
                        },
                        context: f.testContext,
                }
                if captureOut != nil </span><span class="cov8" title="1">{
                        // t.parent aliases f.common.
                        t.parent.w = captureOut
                }</span>
                <span class="cov8" title="1">t.w = indenter{&amp;t.common}
                if t.chatty != nil </span><span class="cov0" title="0">{
                        // TODO(#48132): adjust this to work with test2json.
                        t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)
                }</span>
                <span class="cov8" title="1">f.common.inFuzzFn, f.inFuzzFn = true, true
                go tRunner(t, func(t *T) </span><span class="cov8" title="1">{
                        args := []reflect.Value{reflect.ValueOf(t)}
                        for _, v := range e.Values </span><span class="cov8" title="1">{
                                args = append(args, reflect.ValueOf(v))
                        }</span>
                        // Before resetting the current coverage, defer the snapshot so that
                        // we make sure it is called right before the tRunner function
                        // exits, regardless of whether it was executed cleanly, panicked,
                        // or if the fuzzFn called t.Fatal.
                        <span class="cov8" title="1">if f.testContext.isFuzzing </span><span class="cov0" title="0">{
                                defer f.fuzzContext.deps.SnapshotCoverage()
                                f.fuzzContext.deps.ResetCoverage()
                        }</span>
                        <span class="cov8" title="1">fn.Call(args)</span>
                })
                <span class="cov8" title="1">&lt;-t.signal
                f.common.inFuzzFn, f.inFuzzFn = false, false
                return !t.Failed()</span>
        }

        <span class="cov8" title="1">switch f.fuzzContext.mode </span>{
        case fuzzCoordinator:<span class="cov0" title="0">
                // Fuzzing is enabled, and this is the test process started by 'go test'.
                // Act as the coordinator process, and coordinate workers to perform the
                // actual fuzzing.
                corpusTargetDir := filepath.Join(corpusDir, f.name)
                cacheTargetDir := filepath.Join(*fuzzCacheDir, f.name)
                err := f.fuzzContext.deps.CoordinateFuzzing(
                        fuzzDuration.d,
                        int64(fuzzDuration.n),
                        minimizeDuration.d,
                        int64(minimizeDuration.n),
                        *parallel,
                        f.corpus,
                        types,
                        corpusTargetDir,
                        cacheTargetDir)
                if err != nil </span><span class="cov0" title="0">{
                        f.result = fuzzResult{Error: err}
                        f.Fail()
                        fmt.Fprintf(f.w, "%v\n", err)
                        if crashErr, ok := err.(fuzzCrashError); ok </span><span class="cov0" title="0">{
                                crashPath := crashErr.CrashPath()
                                fmt.Fprintf(f.w, "Failing input written to %s\n", crashPath)
                                testName := filepath.Base(crashPath)
                                fmt.Fprintf(f.w, "To re-run:\ngo test -run=%s/%s\n", f.name, testName)
                        }</span>
                }
                // TODO(jayconrod,katiehockman): Aggregate statistics across workers
                // and add to FuzzResult (ie. time taken, num iterations)

        case fuzzWorker:<span class="cov0" title="0">
                // Fuzzing is enabled, and this is a worker process. Follow instructions
                // from the coordinator.
                if err := f.fuzzContext.deps.RunFuzzWorker(func(e corpusEntry) error </span><span class="cov0" title="0">{
                        // Don't write to f.w (which points to Stdout) if running from a
                        // fuzz worker. This would become very verbose, particularly during
                        // minimization. Return the error instead, and let the caller deal
                        // with the output.
                        var buf bytes.Buffer
                        if ok := run(&amp;buf, e); !ok </span><span class="cov0" title="0">{
                                return errors.New(buf.String())
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        // Internal errors are marked with f.Fail; user code may call this too, before F.Fuzz.
                        // The worker will exit with fuzzWorkerExitCode, indicating this is a failure
                        // (and 'go test' should exit non-zero) but a failing input should not be recorded.
                        f.Errorf("communicating with fuzzing coordinator: %v", err)
                }</span>

        default:<span class="cov8" title="1">
                // Fuzzing is not enabled, or will be done later. Only run the seed
                // corpus now.
                for _, e := range f.corpus </span><span class="cov8" title="1">{
                        name := fmt.Sprintf("%s/%s", f.name, filepath.Base(e.Path))
                        if _, ok, _ := f.testContext.match.fullName(nil, name); ok </span><span class="cov8" title="1">{
                                run(f.w, e)
                        }</span>
                }
        }
}

func (f *F) report() <span class="cov8" title="1">{
        if *isFuzzWorker || f.parent == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">dstr := fmtDuration(f.duration)
        format := "--- %s: %s (%s)\n"
        if f.Failed() </span><span class="cov0" title="0">{
                f.flushToParent(f.name, format, "FAIL", f.name, dstr)
        }</span> else<span class="cov8" title="1"> if f.chatty != nil </span><span class="cov0" title="0">{
                if f.Skipped() </span><span class="cov0" title="0">{
                        f.flushToParent(f.name, format, "SKIP", f.name, dstr)
                }</span> else<span class="cov0" title="0"> {
                        f.flushToParent(f.name, format, "PASS", f.name, dstr)
                }</span>
        }
}

// fuzzResult contains the results of a fuzz run.
type fuzzResult struct {
        N     int           // The number of iterations.
        T     time.Duration // The total time taken.
        Error error         // Error is the error from the failing input
}

func (r fuzzResult) String() string <span class="cov0" title="0">{
        if r.Error == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return r.Error.Error()</span>
}

// fuzzCrashError is satisfied by a failing input detected while fuzzing.
// These errors are written to the seed corpus and can be re-run with 'go test'.
// Errors within the fuzzing framework (like I/O errors between coordinator
// and worker processes) don't satisfy this interface.
type fuzzCrashError interface {
        error
        Unwrap() error

        // CrashPath returns the path of the subtest that corresponds to the saved
        // crash input file in the seed corpus. The test can be re-run with go test
        // -run=$test/$name $test is the fuzz test name, and $name is the
        // filepath.Base of the string returned here.
        CrashPath() string
}

// fuzzContext holds fields common to all fuzz tests.
type fuzzContext struct {
        deps testDeps
        mode fuzzMode
}

type fuzzMode uint8

const (
        seedCorpusOnly fuzzMode = iota
        fuzzCoordinator
        fuzzWorker
)

// runFuzzTests runs the fuzz tests matching the pattern for -run. This will
// only run the (*F).Fuzz function for each seed corpus without using the
// fuzzing engine to generate or mutate inputs.
func runFuzzTests(deps testDeps, fuzzTests []InternalFuzzTarget, deadline time.Time) (ran, ok bool) <span class="cov8" title="1">{
        ok = true
        if len(fuzzTests) == 0 || *isFuzzWorker </span><span class="cov0" title="0">{
                return ran, ok
        }</span>
        <span class="cov8" title="1">m := newMatcher(deps.MatchString, *match, "-test.run")
        tctx := newTestContext(*parallel, m)
        tctx.deadline = deadline
        var mFuzz *matcher
        if *matchFuzz != "" </span><span class="cov0" title="0">{
                mFuzz = newMatcher(deps.MatchString, *matchFuzz, "-test.fuzz")
        }</span>
        <span class="cov8" title="1">fctx := &amp;fuzzContext{deps: deps, mode: seedCorpusOnly}
        root := common{w: os.Stdout} // gather output in one place
        if Verbose() </span><span class="cov0" title="0">{
                root.chatty = newChattyPrinter(root.w)
        }</span>
        <span class="cov8" title="1">for _, ft := range fuzzTests </span><span class="cov8" title="1">{
                if shouldFailFast() </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">testName, matched, _ := tctx.match.fullName(nil, ft.Name)
                if !matched </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if mFuzz != nil </span><span class="cov0" title="0">{
                        if _, fuzzMatched, _ := mFuzz.fullName(nil, ft.Name); fuzzMatched </span><span class="cov0" title="0">{
                                // If this will be fuzzed, then don't run the seed corpus
                                // right now. That will happen later.
                                continue</span>
                        }
                }
                <span class="cov8" title="1">f := &amp;F{
                        common: common{
                                signal:  make(chan bool),
                                barrier: make(chan bool),
                                name:    testName,
                                parent:  &amp;root,
                                level:   root.level + 1,
                                chatty:  root.chatty,
                        },
                        testContext: tctx,
                        fuzzContext: fctx,
                }
                f.w = indenter{&amp;f.common}
                if f.chatty != nil </span><span class="cov0" title="0">{
                        // TODO(#48132): adjust this to work with test2json.
                        f.chatty.Updatef(f.name, "=== RUN   %s\n", f.name)
                }</span>

                <span class="cov8" title="1">go fRunner(f, ft.Fn)
                &lt;-f.signal</span>
        }
        <span class="cov8" title="1">return root.ran, !root.Failed()</span>
}

// runFuzzing runs the fuzz test matching the pattern for -fuzz. Only one such
// fuzz test must match. This will run the fuzzing engine to generate and
// mutate new inputs against the fuzz target.
//
// If fuzzing is disabled (-test.fuzz is not set), runFuzzing
// returns immediately.
func runFuzzing(deps testDeps, fuzzTests []InternalFuzzTarget) (ok bool) <span class="cov8" title="1">{
        if len(fuzzTests) == 0 || *matchFuzz == "" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">m := newMatcher(deps.MatchString, *matchFuzz, "-test.fuzz")
        tctx := newTestContext(1, m)
        tctx.isFuzzing = true
        fctx := &amp;fuzzContext{
                deps: deps,
        }
        root := common{w: os.Stdout}
        if *isFuzzWorker </span><span class="cov0" title="0">{
                root.w = io.Discard
                fctx.mode = fuzzWorker
        }</span> else<span class="cov0" title="0"> {
                fctx.mode = fuzzCoordinator
        }</span>
        <span class="cov0" title="0">if Verbose() &amp;&amp; !*isFuzzWorker </span><span class="cov0" title="0">{
                root.chatty = newChattyPrinter(root.w)
        }</span>
        <span class="cov0" title="0">var fuzzTest *InternalFuzzTarget
        var testName string
        var matched []string
        for i := range fuzzTests </span><span class="cov0" title="0">{
                name, ok, _ := tctx.match.fullName(nil, fuzzTests[i].Name)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">matched = append(matched, name)
                fuzzTest = &amp;fuzzTests[i]
                testName = name</span>
        }
        <span class="cov0" title="0">if len(matched) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: warning: no fuzz tests to fuzz")
                return true
        }</span>
        <span class="cov0" title="0">if len(matched) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: will not fuzz, -fuzz matches more than one fuzz test: %v\n", matched)
                return false
        }</span>

        <span class="cov0" title="0">f := &amp;F{
                common: common{
                        signal:  make(chan bool),
                        barrier: nil, // T.Parallel has no effect when fuzzing.
                        name:    testName,
                        parent:  &amp;root,
                        level:   root.level + 1,
                        chatty:  root.chatty,
                },
                fuzzContext: fctx,
                testContext: tctx,
        }
        f.w = indenter{&amp;f.common}
        if f.chatty != nil </span><span class="cov0" title="0">{
                // TODO(#48132): adjust this to work with test2json.
                f.chatty.Updatef(f.name, "=== FUZZ  %s\n", f.name)
        }</span>
        <span class="cov0" title="0">go fRunner(f, fuzzTest.Fn)
        &lt;-f.signal
        return !f.failed</span>
}

// fRunner wraps a call to a fuzz test and ensures that cleanup functions are
// called and status flags are set. fRunner should be called in its own
// goroutine. To wait for its completion, receive from f.signal.
//
// fRunner is analogous to tRunner, which wraps subtests started with T.Run.
// Unit tests and fuzz tests work a little differently, so for now, these
// functions aren't consolidated. In particular, because there are no F.Run and
// F.Parallel methods, i.e., no fuzz sub-tests or parallel fuzz tests, a few
// simplifications are made. We also require that F.Fuzz, F.Skip, or F.Fail is
// called.
func fRunner(f *F, fn func(*F)) <span class="cov8" title="1">{
        // When this goroutine is done, either because runtime.Goexit was called, a
        // panic started, or fn returned normally, record the duration and send
        // t.signal, indicating the fuzz test is done.
        defer func() </span><span class="cov8" title="1">{
                // Detect whether the fuzz test panicked or called runtime.Goexit
                // without calling F.Fuzz, F.Fail, or F.Skip. If it did, panic (possibly
                // replacing a nil panic value). Nothing should recover after fRunner
                // unwinds, so this should crash the process and print stack.
                // Unfortunately, recovering here adds stack frames, but the location of
                // the original panic should still be
                // clear.
                if f.Failed() </span><span class="cov0" title="0">{
                        atomic.AddUint32(&amp;numFailed, 1)
                }</span>
                <span class="cov8" title="1">err := recover()
                if err == nil </span><span class="cov8" title="1">{
                        f.mu.RLock()
                        fuzzNotCalled := !f.fuzzCalled &amp;&amp; !f.skipped &amp;&amp; !f.failed
                        if !f.finished &amp;&amp; !f.skipped &amp;&amp; !f.failed </span><span class="cov0" title="0">{
                                err = errNilPanicOrGoexit
                        }</span>
                        <span class="cov8" title="1">f.mu.RUnlock()
                        if fuzzNotCalled &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                f.Error("returned without calling F.Fuzz, F.Fail, or F.Skip")
                        }</span>
                }

                // Use a deferred call to ensure that we report that the test is
                // complete even if a cleanup function calls F.FailNow. See issue 41355.
                <span class="cov8" title="1">didPanic := false
                defer func() </span><span class="cov8" title="1">{
                        if !didPanic </span><span class="cov8" title="1">{
                                // Only report that the test is complete if it doesn't panic,
                                // as otherwise the test binary can exit before the panic is
                                // reported to the user. See issue 41479.
                                f.signal &lt;- true
                        }</span>
                }()

                // If we recovered a panic or inappropriate runtime.Goexit, fail the test,
                // flush the output log up to the root, then panic.
                <span class="cov8" title="1">doPanic := func(err any) </span><span class="cov0" title="0">{
                        f.Fail()
                        if r := f.runCleanup(recoverAndReturnPanic); r != nil </span><span class="cov0" title="0">{
                                f.Logf("cleanup panicked with %v", r)
                        }</span>
                        <span class="cov0" title="0">for root := &amp;f.common; root.parent != nil; root = root.parent </span><span class="cov0" title="0">{
                                root.mu.Lock()
                                root.duration += time.Since(root.start)
                                d := root.duration
                                root.mu.Unlock()
                                root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))
                        }</span>
                        <span class="cov0" title="0">didPanic = true
                        panic(err)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        doPanic(err)
                }</span>

                // No panic or inappropriate Goexit.
                <span class="cov8" title="1">f.duration += time.Since(f.start)

                if len(f.sub) &gt; 0 </span><span class="cov0" title="0">{
                        // Unblock inputs that called T.Parallel while running the seed corpus.
                        // This only affects fuzz tests run as normal tests.
                        // While fuzzing, T.Parallel has no effect, so f.sub is empty, and this
                        // branch is not taken. f.barrier is nil in that case.
                        f.testContext.release()
                        close(f.barrier)
                        // Wait for the subtests to complete.
                        for _, sub := range f.sub </span><span class="cov0" title="0">{
                                &lt;-sub.signal
                        }</span>
                        <span class="cov0" title="0">cleanupStart := time.Now()
                        err := f.runCleanup(recoverAndReturnPanic)
                        f.duration += time.Since(cleanupStart)
                        if err != nil </span><span class="cov0" title="0">{
                                doPanic(err)
                        }</span>
                }

                // Report after all subtests have finished.
                <span class="cov8" title="1">f.report()
                f.done = true
                f.setRan()</span>
        }()
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if len(f.sub) == 0 </span><span class="cov8" title="1">{
                        f.runCleanup(normalPanic)
                }</span>
        }()

        <span class="cov8" title="1">f.start = time.Now()
        fn(f)

        // Code beyond this point will not be executed when FailNow or SkipNow
        // is invoked.
        f.mu.Lock()
        f.finished = true
        f.mu.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package testing

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
)

// matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.
type matcher struct {
        filter    filterMatch
        matchFunc func(pat, str string) (bool, error)

        mu sync.Mutex

        // subNames is used to deduplicate subtest names.
        // Each key is the subtest name joined to the deduplicated name of the parent test.
        // Each value is the count of the number of occurrences of the given subtest name
        // already seen.
        subNames map[string]int32
}

type filterMatch interface {
        // matches checks the name against the receiver's pattern strings using the
        // given match function.
        matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool)

        // verify checks that the receiver's pattern strings are valid filters by
        // calling the given match function.
        verify(name string, matchString func(pat, str string) (bool, error)) error
}

// simpleMatch matches a test name if all of the pattern strings match in
// sequence.
type simpleMatch []string

// alternationMatch matches a test name if one of the alternations match.
type alternationMatch []filterMatch

// TODO: fix test_main to avoid race and improve caching, also allowing to
// eliminate this Mutex.
var matchMutex sync.Mutex

func newMatcher(matchString func(pat, str string) (bool, error), patterns, name string) *matcher <span class="cov8" title="1">{
        var impl filterMatch
        if patterns != "" </span><span class="cov8" title="1">{
                impl = splitRegexp(patterns)
                if err := impl.verify(name, matchString); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: invalid regexp for %s\n", err)
                        os.Exit(1)
                }</span>
        }
        <span class="cov8" title="1">return &amp;matcher{
                filter:    impl,
                matchFunc: matchString,
                subNames:  map[string]int32{},
        }</span>
}

func (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool) <span class="cov8" title="1">{
        name = subname

        m.mu.Lock()
        defer m.mu.Unlock()

        if c != nil &amp;&amp; c.level &gt; 0 </span><span class="cov8" title="1">{
                name = m.unique(c.name, rewrite(subname))
        }</span>

        <span class="cov8" title="1">matchMutex.Lock()
        defer matchMutex.Unlock()

        if m.filter == nil </span><span class="cov8" title="1">{
                return name, true, false
        }</span>

        // We check the full array of paths each time to allow for the case that
        // a pattern contains a '/'.
        <span class="cov8" title="1">elem := strings.Split(name, "/")
        ok, partial = m.filter.matches(elem, m.matchFunc)
        return name, ok, partial</span>
}

// clearSubNames clears the matcher's internal state, potentially freeing
// memory. After this is called, T.Name may return the same strings as it did
// for earlier subtests.
func (m *matcher) clearSubNames() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        for key := range m.subNames </span><span class="cov0" title="0">{
                delete(m.subNames, key)
        }</span>
}

func (m simpleMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) <span class="cov8" title="1">{
        for i, s := range name </span><span class="cov8" title="1">{
                if i &gt;= len(m) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if ok, _ := matchString(m[i], s); !ok </span><span class="cov8" title="1">{
                        return false, false
                }</span>
        }
        <span class="cov8" title="1">return true, len(name) &lt; len(m)</span>
}

func (m simpleMatch) verify(name string, matchString func(pat, str string) (bool, error)) error <span class="cov8" title="1">{
        for i, s := range m </span><span class="cov8" title="1">{
                m[i] = rewrite(s)
        }</span>
        // Verify filters before doing any processing.
        <span class="cov8" title="1">for i, s := range m </span><span class="cov8" title="1">{
                if _, err := matchString(s, "non-empty"); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("element %d of %s (%q): %s", i, name, s, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m alternationMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) <span class="cov8" title="1">{
        for _, m := range m </span><span class="cov8" title="1">{
                if ok, partial = m.matches(name, matchString); ok </span><span class="cov8" title="1">{
                        return ok, partial
                }</span>
        }
        <span class="cov8" title="1">return false, false</span>
}

func (m alternationMatch) verify(name string, matchString func(pat, str string) (bool, error)) error <span class="cov8" title="1">{
        for i, m := range m </span><span class="cov8" title="1">{
                if err := m.verify(name, matchString); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("alternation %d of %s", i, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func splitRegexp(s string) filterMatch <span class="cov8" title="1">{
        a := make(simpleMatch, 0, strings.Count(s, "/"))
        b := make(alternationMatch, 0, strings.Count(s, "|"))
        cs := 0
        cp := 0
        for i := 0; i &lt; len(s); </span><span class="cov8" title="1">{
                switch s[i] </span>{
                case '[':<span class="cov8" title="1">
                        cs++</span>
                case ']':<span class="cov8" title="1">
                        if cs--; cs &lt; 0 </span><span class="cov8" title="1">{ // An unmatched ']' is legal.
                                cs = 0
                        }</span>
                case '(':<span class="cov8" title="1">
                        if cs == 0 </span><span class="cov8" title="1">{
                                cp++
                        }</span>
                case ')':<span class="cov8" title="1">
                        if cs == 0 </span><span class="cov8" title="1">{
                                cp--
                        }</span>
                case '\\':<span class="cov8" title="1">
                        i++</span>
                case '/':<span class="cov8" title="1">
                        if cs == 0 &amp;&amp; cp == 0 </span><span class="cov8" title="1">{
                                a = append(a, s[:i])
                                s = s[i+1:]
                                i = 0
                                continue</span>
                        }
                case '|':<span class="cov8" title="1">
                        if cs == 0 &amp;&amp; cp == 0 </span><span class="cov8" title="1">{
                                a = append(a, s[:i])
                                s = s[i+1:]
                                i = 0
                                b = append(b, a)
                                a = make(simpleMatch, 0, len(a))
                                continue</span>
                        }
                }
                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">a = append(a, s)
        if len(b) == 0 </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return append(b, a)</span>
}

// unique creates a unique name for the given parent and subname by affixing it
// with one or more counts, if necessary.
func (m *matcher) unique(parent, subname string) string <span class="cov8" title="1">{
        base := parent + "/" + subname

        for </span><span class="cov8" title="1">{
                n := m.subNames[base]
                if n &lt; 0 </span><span class="cov0" title="0">{
                        panic("subtest count overflow")</span>
                }
                <span class="cov8" title="1">m.subNames[base] = n + 1

                if n == 0 &amp;&amp; subname != "" </span><span class="cov8" title="1">{
                        prefix, nn := parseSubtestNumber(base)
                        if len(prefix) &lt; len(base) &amp;&amp; nn &lt; m.subNames[prefix] </span><span class="cov8" title="1">{
                                // This test is explicitly named like "parent/subname#NN",
                                // and #NN was already used for the NNth occurrence of "parent/subname".
                                // Loop to add a disambiguating suffix.
                                continue</span>
                        }
                        <span class="cov8" title="1">return base</span>
                }

                <span class="cov8" title="1">name := fmt.Sprintf("%s#%02d", base, n)
                if m.subNames[name] != 0 </span><span class="cov8" title="1">{
                        // This is the nth occurrence of base, but the name "parent/subname#NN"
                        // collides with the first occurrence of a subtest *explicitly* named
                        // "parent/subname#NN". Try the next number.
                        continue</span>
                }

                <span class="cov8" title="1">return name</span>
        }
}

// parseSubtestNumber splits a subtest name into a "#%02d"-formatted int32
// suffix (if present), and a prefix preceding that suffix (always).
func parseSubtestNumber(s string) (prefix string, nn int32) <span class="cov8" title="1">{
        i := strings.LastIndex(s, "#")
        if i &lt; 0 </span><span class="cov8" title="1">{
                return s, 0
        }</span>

        <span class="cov8" title="1">prefix, suffix := s[:i], s[i+1:]
        if len(suffix) &lt; 2 || (len(suffix) &gt; 2 &amp;&amp; suffix[0] == '0') </span><span class="cov8" title="1">{
                // Even if suffix is numeric, it is not a possible output of a "%02" format
                // string: it has either too few digits or too many leading zeroes.
                return s, 0
        }</span>
        <span class="cov8" title="1">if suffix == "00" </span><span class="cov8" title="1">{
                if !strings.HasSuffix(prefix, "/") </span><span class="cov8" title="1">{
                        // We only use "#00" as a suffix for subtests named with the empty
                        // string — it isn't a valid suffix if the subtest name is non-empty.
                        return s, 0
                }</span>
        }

        <span class="cov8" title="1">n, err := strconv.ParseInt(suffix, 10, 32)
        if err != nil || n &lt; 0 </span><span class="cov8" title="1">{
                return s, 0
        }</span>
        <span class="cov8" title="1">return prefix, int32(n)</span>
}

// rewrite rewrites a subname to having only printable characters and no white
// space.
func rewrite(s string) string <span class="cov8" title="1">{
        b := []byte{}
        for _, r := range s </span><span class="cov8" title="1">{
                switch </span>{
                case isSpace(r):<span class="cov8" title="1">
                        b = append(b, '_')</span>
                case !strconv.IsPrint(r):<span class="cov8" title="1">
                        s := strconv.QuoteRune(r)
                        b = append(b, s[1:len(s)-1]...)</span>
                default:<span class="cov8" title="1">
                        b = append(b, string(r)...)</span>
                }
        }
        <span class="cov8" title="1">return string(b)</span>
}

func isSpace(r rune) bool <span class="cov8" title="1">{
        if r &lt; 0x2000 </span><span class="cov8" title="1">{
                switch r </span>{
                // Note: not the same as Unicode Z class.
                case '\t', '\n', '\v', '\f', '\r', ' ', 0x85, 0xA0, 0x1680:<span class="cov8" title="1">
                        return true</span>
                }
        } else<span class="cov8" title="1"> {
                if r &lt;= 0x200a </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">switch r </span>{
                case 0x2028, 0x2029, 0x202f, 0x205f, 0x3000:<span class="cov8" title="1">
                        return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !js

// TODO(@musiol, @odeke-em): re-unify this entire file back into
// example.go when js/wasm gets an os.Pipe implementation
// and no longer needs this separation.

package testing

import (
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

func runExample(eg InternalExample) (ok bool) <span class="cov0" title="0">{
        if *chatty </span><span class="cov0" title="0">{
                fmt.Printf("=== RUN   %s\n", eg.Name)
        }</span>

        // Capture stdout.
        <span class="cov0" title="0">stdout := os.Stdout
        r, w, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">os.Stdout = w
        outC := make(chan string)
        go func() </span><span class="cov0" title="0">{
                var buf strings.Builder
                _, err := io.Copy(&amp;buf, r)
                r.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: copying pipe: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">finished := false
        start := time.Now()

        // Clean up in a deferred call so we can recover if the example panics.
        defer func() </span><span class="cov0" title="0">{
                timeSpent := time.Since(start)

                // Close pipe, restore stdout, get output.
                w.Close()
                os.Stdout = stdout
                out := &lt;-outC

                err := recover()
                ok = eg.processRunResult(out, timeSpent, finished, err)
        }</span>()

        // Run example.
        <span class="cov0" title="0">eg.F()
        finished = true
        return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package testing provides support for automated testing of Go packages.
// It is intended to be used in concert with the "go test" command, which automates
// execution of any function of the form
//
//        func TestXxx(*testing.T)
//
// where Xxx does not start with a lowercase letter. The function name
// serves to identify the test routine.
//
// Within these functions, use the Error, Fail or related methods to signal failure.
//
// To write a new test suite, create a file whose name ends _test.go that
// contains the TestXxx functions as described here. Put the file in the same
// package as the one being tested. The file will be excluded from regular
// package builds but will be included when the "go test" command is run.
// For more detail, run "go help test" and "go help testflag".
//
// A simple test function looks like this:
//
//        func TestAbs(t *testing.T) {
//            got := Abs(-1)
//            if got != 1 {
//                t.Errorf("Abs(-1) = %d; want 1", got)
//            }
//        }
//
// # Benchmarks
//
// Functions of the form
//
//        func BenchmarkXxx(*testing.B)
//
// are considered benchmarks, and are executed by the "go test" command when
// its -bench flag is provided. Benchmarks are run sequentially.
//
// For a description of the testing flags, see
// https://golang.org/cmd/go/#hdr-Testing_flags.
//
// A sample benchmark function looks like this:
//
//        func BenchmarkRandInt(b *testing.B) {
//            for i := 0; i &lt; b.N; i++ {
//                rand.Int()
//            }
//        }
//
// The benchmark function must run the target code b.N times.
// During benchmark execution, b.N is adjusted until the benchmark function lasts
// long enough to be timed reliably. The output
//
//        BenchmarkRandInt-8           68453040                17.8 ns/op
//
// means that the loop ran 68453040 times at a speed of 17.8 ns per loop.
//
// If a benchmark needs some expensive setup before running, the timer
// may be reset:
//
//        func BenchmarkBigLen(b *testing.B) {
//            big := NewBig()
//            b.ResetTimer()
//            for i := 0; i &lt; b.N; i++ {
//                big.Len()
//            }
//        }
//
// If a benchmark needs to test performance in a parallel setting, it may use
// the RunParallel helper function; such benchmarks are intended to be used with
// the go test -cpu flag:
//
//        func BenchmarkTemplateParallel(b *testing.B) {
//            templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))
//            b.RunParallel(func(pb *testing.PB) {
//                var buf bytes.Buffer
//                for pb.Next() {
//                    buf.Reset()
//                    templ.Execute(&amp;buf, "World")
//                }
//            })
//        }
//
// A detailed specification of the benchmark results format is given
// in https://golang.org/design/14313-benchmark-format.
//
// There are standard tools for working with benchmark results at
// https://golang.org/x/perf/cmd.
// In particular, https://golang.org/x/perf/cmd/benchstat performs
// statistically robust A/B comparisons.
//
// # Examples
//
// The package also runs and verifies example code. Example functions may
// include a concluding line comment that begins with "Output:" and is compared with
// the standard output of the function when the tests are run. (The comparison
// ignores leading and trailing space.) These are examples of an example:
//
//        func ExampleHello() {
//            fmt.Println("hello")
//            // Output: hello
//        }
//
//        func ExampleSalutations() {
//            fmt.Println("hello, and")
//            fmt.Println("goodbye")
//            // Output:
//            // hello, and
//            // goodbye
//        }
//
// The comment prefix "Unordered output:" is like "Output:", but matches any
// line order:
//
//        func ExamplePerm() {
//            for _, value := range Perm(5) {
//                fmt.Println(value)
//            }
//            // Unordered output: 4
//            // 2
//            // 1
//            // 3
//            // 0
//        }
//
// Example functions without output comments are compiled but not executed.
//
// The naming convention to declare examples for the package, a function F, a type T and
// method M on type T are:
//
//        func Example() { ... }
//        func ExampleF() { ... }
//        func ExampleT() { ... }
//        func ExampleT_M() { ... }
//
// Multiple example functions for a package/type/function/method may be provided by
// appending a distinct suffix to the name. The suffix must start with a
// lower-case letter.
//
//        func Example_suffix() { ... }
//        func ExampleF_suffix() { ... }
//        func ExampleT_suffix() { ... }
//        func ExampleT_M_suffix() { ... }
//
// The entire test file is presented as the example when it contains a single
// example function, at least one other function, type, variable, or constant
// declaration, and no test or benchmark functions.
//
// # Fuzzing
//
// 'go test' and the testing package support fuzzing, a testing technique where
// a function is called with randomly generated inputs to find bugs not
// anticipated by unit tests.
//
// Functions of the form
//
//        func FuzzXxx(*testing.F)
//
// are considered fuzz tests.
//
// For example:
//
//        func FuzzHex(f *testing.F) {
//          for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {
//            f.Add(seed)
//          }
//          f.Fuzz(func(t *testing.T, in []byte) {
//            enc := hex.EncodeToString(in)
//            out, err := hex.DecodeString(enc)
//            if err != nil {
//              t.Fatalf("%v: decode: %v", in, err)
//            }
//            if !bytes.Equal(in, out) {
//              t.Fatalf("%v: not equal after round trip: %v", in, out)
//            }
//          })
//        }
//
// A fuzz test maintains a seed corpus, or a set of inputs which are run by
// default, and can seed input generation. Seed inputs may be registered by
// calling (*F).Add or by storing files in the directory testdata/fuzz/&lt;Name&gt;
// (where &lt;Name&gt; is the name of the fuzz test) within the package containing
// the fuzz test. Seed inputs are optional, but the fuzzing engine may find
// bugs more efficiently when provided with a set of small seed inputs with good
// code coverage. These seed inputs can also serve as regression tests for bugs
// identified through fuzzing.
//
// The function passed to (*F).Fuzz within the fuzz test is considered the fuzz
// target. A fuzz target must accept a *T parameter, followed by one or more
// parameters for random inputs. The types of arguments passed to (*F).Add must
// be identical to the types of these parameters. The fuzz target may signal
// that it's found a problem the same way tests do: by calling T.Fail (or any
// method that calls it like T.Error or T.Fatal) or by panicking.
//
// When fuzzing is enabled (by setting the -fuzz flag to a regular expression
// that matches a specific fuzz test), the fuzz target is called with arguments
// generated by repeatedly making random changes to the seed inputs. On
// supported platforms, 'go test' compiles the test executable with fuzzing
// coverage instrumentation. The fuzzing engine uses that instrumentation to
// find and cache inputs that expand coverage, increasing the likelihood of
// finding bugs. If the fuzz target fails for a given input, the fuzzing engine
// writes the inputs that caused the failure to a file in the directory
// testdata/fuzz/&lt;Name&gt; within the package directory. This file later serves as
// a seed input. If the file can't be written at that location (for example,
// because the directory is read-only), the fuzzing engine writes the file to
// the fuzz cache directory within the build cache instead.
//
// When fuzzing is disabled, the fuzz target is called with the seed inputs
// registered with F.Add and seed inputs from testdata/fuzz/&lt;Name&gt;. In this
// mode, the fuzz test acts much like a regular test, with subtests started
// with F.Fuzz instead of T.Run.
//
// See https://go.dev/doc/fuzz for documentation about fuzzing.
//
// # Skipping
//
// Tests or benchmarks may be skipped at run time with a call to
// the Skip method of *T or *B:
//
//        func TestTimeConsuming(t *testing.T) {
//            if testing.Short() {
//                t.Skip("skipping test in short mode.")
//            }
//            ...
//        }
//
// The Skip method of *T can be used in a fuzz target if the input is invalid,
// but should not be considered a failing input. For example:
//
//        func FuzzJSONMarshaling(f *testing.F) {
//            f.Fuzz(func(t *testing.T, b []byte) {
//                var v interface{}
//                if err := json.Unmarshal(b, &amp;v); err != nil {
//                    t.Skip()
//                }
//                if _, err := json.Marshal(v); err != nil {
//                    t.Error("Marshal: %v", err)
//                }
//            })
//        }
//
// # Subtests and Sub-benchmarks
//
// The Run methods of T and B allow defining subtests and sub-benchmarks,
// without having to define separate functions for each. This enables uses
// like table-driven benchmarks and creating hierarchical tests.
// It also provides a way to share common setup and tear-down code:
//
//        func TestFoo(t *testing.T) {
//            // &lt;setup code&gt;
//            t.Run("A=1", func(t *testing.T) { ... })
//            t.Run("A=2", func(t *testing.T) { ... })
//            t.Run("B=1", func(t *testing.T) { ... })
//            // &lt;tear-down code&gt;
//        }
//
// Each subtest and sub-benchmark has a unique name: the combination of the name
// of the top-level test and the sequence of names passed to Run, separated by
// slashes, with an optional trailing sequence number for disambiguation.
//
// The argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular
// expression that matches the test's name. For tests with multiple slash-separated
// elements, such as subtests, the argument is itself slash-separated, with
// expressions matching each name element in turn. Because it is unanchored, an
// empty expression matches any string.
// For example, using "matching" to mean "whose name contains":
//
//        go test -run ''        # Run all tests.
//        go test -run Foo       # Run top-level tests matching "Foo", such as "TestFooBar".
//        go test -run Foo/A=    # For top-level tests matching "Foo", run subtests matching "A=".
//        go test -run /A=1      # For all top-level tests, run subtests matching "A=1".
//        go test -fuzz FuzzFoo  # Fuzz the target matching "FuzzFoo"
//
// The -run argument can also be used to run a specific value in the seed
// corpus, for debugging. For example:
//
//        go test -run=FuzzFoo/9ddb952d9814
//
// The -fuzz and -run flags can both be set, in order to fuzz a target but
// skip the execution of all other tests.
//
// Subtests can also be used to control parallelism. A parent test will only
// complete once all of its subtests complete. In this example, all tests are
// run in parallel with each other, and only with each other, regardless of
// other top-level tests that may be defined:
//
//        func TestGroupedParallel(t *testing.T) {
//            for _, tc := range tests {
//                tc := tc // capture range variable
//                t.Run(tc.Name, func(t *testing.T) {
//                    t.Parallel()
//                    ...
//                })
//            }
//        }
//
// Run does not return until parallel subtests have completed, providing a way
// to clean up after a group of parallel tests:
//
//        func TestTeardownParallel(t *testing.T) {
//            // This Run will not return until the parallel tests finish.
//            t.Run("group", func(t *testing.T) {
//                t.Run("Test1", parallelTest1)
//                t.Run("Test2", parallelTest2)
//                t.Run("Test3", parallelTest3)
//            })
//            // &lt;tear-down code&gt;
//        }
//
// # Main
//
// It is sometimes necessary for a test or benchmark program to do extra setup or teardown
// before or after it executes. It is also sometimes necessary to control
// which code runs on the main thread. To support these and other cases,
// if a test file contains a function:
//
//        func TestMain(m *testing.M)
//
// then the generated test will call TestMain(m) instead of running the tests or benchmarks
// directly. TestMain runs in the main goroutine and can do whatever setup
// and teardown is necessary around a call to m.Run. m.Run will return an exit
// code that may be passed to os.Exit. If TestMain returns, the test wrapper
// will pass the result of m.Run to os.Exit itself.
//
// When TestMain is called, flag.Parse has not been run. If TestMain depends on
// command-line flags, including those of the testing package, it should call
// flag.Parse explicitly. Command line flags are always parsed by the time test
// or benchmark functions run.
//
// A simple implementation of TestMain is:
//
//        func TestMain(m *testing.M) {
//                // call flag.Parse() here if TestMain uses flags
//                os.Exit(m.Run())
//        }
//
// TestMain is a low-level primitive and should not be necessary for casual
// testing needs, where ordinary test functions suffice.
package testing

import (
        "bytes"
        "errors"
        "flag"
        "fmt"
        "internal/race"
        "io"
        "math/rand"
        "os"
        "reflect"
        "runtime"
        "runtime/debug"
        "runtime/trace"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
        "unicode"
        "unicode/utf8"
)

var initRan bool

// Init registers testing flags. These flags are automatically registered by
// the "go test" command before running test functions, so Init is only needed
// when calling functions such as Benchmark without using "go test".
//
// Init has no effect if it was already called.
func Init() <span class="cov8" title="1">{
        if initRan </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">initRan = true
        // The short flag requests that tests run more quickly, but its functionality
        // is provided by test writers themselves. The testing package is just its
        // home. The all.bash installation script sets it to make installation more
        // efficient, but by default the flag is off so a plain "go test" will do a
        // full test of the package.
        short = flag.Bool("test.short", false, "run smaller test suite to save time")

        // The failfast flag requests that test execution stop after the first test failure.
        failFast = flag.Bool("test.failfast", false, "do not start new tests after the first test failure")

        // The directory in which to create profile files and the like. When run from
        // "go test", the binary always runs in the source directory for the package;
        // this flag lets "go test" tell the binary to write the files in the directory where
        // the "go test" command is run.
        outputDir = flag.String("test.outputdir", "", "write profiles to `dir`")
        // Report as tests are run; default is silent for success.
        chatty = flag.Bool("test.v", false, "verbose: print additional output")
        count = flag.Uint("test.count", 1, "run tests and benchmarks `n` times")
        coverProfile = flag.String("test.coverprofile", "", "write a coverage profile to `file`")
        matchList = flag.String("test.list", "", "list tests, examples, and benchmarks matching `regexp` then exit")
        match = flag.String("test.run", "", "run only tests and examples matching `regexp`")
        memProfile = flag.String("test.memprofile", "", "write an allocation profile to `file`")
        memProfileRate = flag.Int("test.memprofilerate", 0, "set memory allocation profiling `rate` (see runtime.MemProfileRate)")
        cpuProfile = flag.String("test.cpuprofile", "", "write a cpu profile to `file`")
        blockProfile = flag.String("test.blockprofile", "", "write a goroutine blocking profile to `file`")
        blockProfileRate = flag.Int("test.blockprofilerate", 1, "set blocking profile `rate` (see runtime.SetBlockProfileRate)")
        mutexProfile = flag.String("test.mutexprofile", "", "write a mutex contention profile to the named file after execution")
        mutexProfileFraction = flag.Int("test.mutexprofilefraction", 1, "if &gt;= 0, calls runtime.SetMutexProfileFraction()")
        panicOnExit0 = flag.Bool("test.paniconexit0", false, "panic on call to os.Exit(0)")
        traceFile = flag.String("test.trace", "", "write an execution trace to `file`")
        timeout = flag.Duration("test.timeout", 0, "panic test binary after duration `d` (default 0, timeout disabled)")
        cpuListStr = flag.String("test.cpu", "", "comma-separated `list` of cpu counts to run each test with")
        parallel = flag.Int("test.parallel", runtime.GOMAXPROCS(0), "run at most `n` tests in parallel")
        testlog = flag.String("test.testlogfile", "", "write test action log to `file` (for use only by cmd/go)")
        shuffle = flag.String("test.shuffle", "off", "randomize the execution order of tests and benchmarks")

        initBenchmarkFlags()
        initFuzzFlags()</span>
}

var (
        // Flags, registered during Init.
        short                *bool
        failFast             *bool
        outputDir            *string
        chatty               *bool
        count                *uint
        coverProfile         *string
        matchList            *string
        match                *string
        memProfile           *string
        memProfileRate       *int
        cpuProfile           *string
        blockProfile         *string
        blockProfileRate     *int
        mutexProfile         *string
        mutexProfileFraction *int
        panicOnExit0         *bool
        traceFile            *string
        timeout              *time.Duration
        cpuListStr           *string
        parallel             *int
        shuffle              *string
        testlog              *string

        haveExamples bool // are there examples?

        cpuList     []int
        testlogFile *os.File

        numFailed uint32 // number of test failures
)

type chattyPrinter struct {
        w          io.Writer
        lastNameMu sync.Mutex // guards lastName
        lastName   string     // last printed test name in chatty mode
}

func newChattyPrinter(w io.Writer) *chattyPrinter <span class="cov8" title="1">{
        return &amp;chattyPrinter{w: w}
}</span>

// Updatef prints a message about the status of the named test to w.
//
// The formatted message must include the test name itself.
func (p *chattyPrinter) Updatef(testName, format string, args ...any) <span class="cov8" title="1">{
        p.lastNameMu.Lock()
        defer p.lastNameMu.Unlock()

        // Since the message already implies an association with a specific new test,
        // we don't need to check what the old test name was or log an extra CONT line
        // for it. (We're updating it anyway, and the current message already includes
        // the test name.)
        p.lastName = testName
        fmt.Fprintf(p.w, format, args...)
}</span>

// Printf prints a message, generated by the named test, that does not
// necessarily mention that tests's name itself.
func (p *chattyPrinter) Printf(testName, format string, args ...any) <span class="cov8" title="1">{
        p.lastNameMu.Lock()
        defer p.lastNameMu.Unlock()

        if p.lastName == "" </span><span class="cov0" title="0">{
                p.lastName = testName
        }</span> else<span class="cov8" title="1"> if p.lastName != testName </span><span class="cov8" title="1">{
                fmt.Fprintf(p.w, "=== CONT  %s\n", testName)
                p.lastName = testName
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(p.w, format, args...)</span>
}

// The maximum number of stack frames to go through when skipping helper functions for
// the purpose of decorating log messages.
const maxStackLen = 50

// common holds the elements common between T and B and
// captures common methods such as Errorf.
type common struct {
        mu          sync.RWMutex         // guards this group of fields
        output      []byte               // Output generated by test or benchmark.
        w           io.Writer            // For flushToParent.
        ran         bool                 // Test or benchmark (or one of its subtests) was executed.
        failed      bool                 // Test or benchmark has failed.
        skipped     bool                 // Test or benchmark has been skipped.
        done        bool                 // Test is finished and all subtests have completed.
        helperPCs   map[uintptr]struct{} // functions to be skipped when writing file/line info
        helperNames map[string]struct{}  // helperPCs converted to function names
        cleanups    []func()             // optional functions to be called at the end of the test
        cleanupName string               // Name of the cleanup function.
        cleanupPc   []uintptr            // The stack trace at the point where Cleanup was called.
        finished    bool                 // Test function has completed.
        inFuzzFn    bool                 // Whether the fuzz target, if this is one, is running.

        chatty     *chattyPrinter // A copy of chattyPrinter, if the chatty flag is set.
        bench      bool           // Whether the current test is a benchmark.
        hasSub     int32          // Written atomically.
        raceErrors int            // Number of races detected during test.
        runner     string         // Function name of tRunner running the test.

        parent   *common
        level    int       // Nesting depth of test or benchmark.
        creator  []uintptr // If level &gt; 0, the stack trace at the point where the parent called t.Run.
        name     string    // Name of test or benchmark.
        start    time.Time // Time test or benchmark started
        duration time.Duration
        barrier  chan bool // To signal parallel subtests they may start. Nil when T.Parallel is not present (B) or not usable (when fuzzing).
        signal   chan bool // To signal a test is done.
        sub      []*T      // Queue of subtests to be run in parallel.

        tempDirMu  sync.Mutex
        tempDir    string
        tempDirErr error
        tempDirSeq int32
}

// Short reports whether the -test.short flag is set.
func Short() bool <span class="cov8" title="1">{
        if short == nil </span><span class="cov0" title="0">{
                panic("testing: Short called before Init")</span>
        }
        // Catch code that calls this from TestMain without first calling flag.Parse.
        <span class="cov8" title="1">if !flag.Parsed() </span><span class="cov0" title="0">{
                panic("testing: Short called before Parse")</span>
        }

        <span class="cov8" title="1">return *short</span>
}

// CoverMode reports what the test coverage mode is set to. The
// values are "set", "count", or "atomic". The return value will be
// empty if test coverage is not enabled.
func CoverMode() string <span class="cov0" title="0">{
        return cover.Mode
}</span>

// Verbose reports whether the -test.v flag is set.
func Verbose() bool <span class="cov8" title="1">{
        // Same as in Short.
        if chatty == nil </span><span class="cov0" title="0">{
                panic("testing: Verbose called before Init")</span>
        }
        <span class="cov8" title="1">if !flag.Parsed() </span><span class="cov0" title="0">{
                panic("testing: Verbose called before Parse")</span>
        }
        <span class="cov8" title="1">return *chatty</span>
}

func (c *common) checkFuzzFn(name string) <span class="cov8" title="1">{
        if c.inFuzzFn </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("testing: f.%s was called inside the fuzz target, use t.%s instead", name, name))</span>
        }
}

// frameSkip searches, starting after skip frames, for the first caller frame
// in a function not marked as a helper and returns that frame.
// The search stops if it finds a tRunner function that
// was the entry point into the test and the test is not a subtest.
// This function must be called with c.mu held.
func (c *common) frameSkip(skip int) runtime.Frame <span class="cov8" title="1">{
        // If the search continues into the parent test, we'll have to hold
        // its mu temporarily. If we then return, we need to unlock it.
        shouldUnlock := false
        defer func() </span><span class="cov8" title="1">{
                if shouldUnlock </span><span class="cov8" title="1">{
                        c.mu.Unlock()
                }</span>
        }()
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        // Skip two extra frames to account for this function
        // and runtime.Callers itself.
        n := runtime.Callers(skip+2, pc[:])
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">frames := runtime.CallersFrames(pc[:n])
        var firstFrame, prevFrame, frame runtime.Frame
        for more := true; more; prevFrame = frame </span><span class="cov8" title="1">{
                frame, more = frames.Next()
                if frame.Function == "runtime.gopanic" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if frame.Function == c.cleanupName </span><span class="cov8" title="1">{
                        frames = runtime.CallersFrames(c.cleanupPc)
                        continue</span>
                }
                <span class="cov8" title="1">if firstFrame.PC == 0 </span><span class="cov8" title="1">{
                        firstFrame = frame
                }</span>
                <span class="cov8" title="1">if frame.Function == c.runner </span><span class="cov8" title="1">{
                        // We've gone up all the way to the tRunner calling
                        // the test function (so the user must have
                        // called tb.Helper from inside that test function).
                        // If this is a top-level test, only skip up to the test function itself.
                        // If we're in a subtest, continue searching in the parent test,
                        // starting from the point of the call to Run which created this subtest.
                        if c.level &gt; 1 </span><span class="cov8" title="1">{
                                frames = runtime.CallersFrames(c.creator)
                                parent := c.parent
                                // We're no longer looking at the current c after this point,
                                // so we should unlock its mu, unless it's the original receiver,
                                // in which case our caller doesn't expect us to do that.
                                if shouldUnlock </span><span class="cov0" title="0">{
                                        c.mu.Unlock()
                                }</span>
                                <span class="cov8" title="1">c = parent
                                // Remember to unlock c.mu when we no longer need it, either
                                // because we went up another nesting level, or because we
                                // returned.
                                shouldUnlock = true
                                c.mu.Lock()
                                continue</span>
                        }
                        <span class="cov8" title="1">return prevFrame</span>
                }
                // If more helper PCs have been added since we last did the conversion
                <span class="cov8" title="1">if c.helperNames == nil </span><span class="cov8" title="1">{
                        c.helperNames = make(map[string]struct{})
                        for pc := range c.helperPCs </span><span class="cov8" title="1">{
                                c.helperNames[pcToName(pc)] = struct{}{}
                        }</span>
                }
                <span class="cov8" title="1">if _, ok := c.helperNames[frame.Function]; !ok </span><span class="cov8" title="1">{
                        // Found a frame that wasn't inside a helper function.
                        return frame
                }</span>
        }
        <span class="cov0" title="0">return firstFrame</span>
}

// decorate prefixes the string with the file and line of the call site
// and inserts the final newline if needed and indentation spaces for formatting.
// This function must be called with c.mu held.
func (c *common) decorate(s string, skip int) string <span class="cov8" title="1">{
        frame := c.frameSkip(skip)
        file := frame.File
        line := frame.Line
        if file != "" </span><span class="cov8" title="1">{
                // Truncate file name at last file name separator.
                if index := strings.LastIndex(file, "/"); index &gt;= 0 </span><span class="cov8" title="1">{
                        file = file[index+1:]
                }</span> else<span class="cov0" title="0"> if index = strings.LastIndex(file, "\\"); index &gt;= 0 </span><span class="cov0" title="0">{
                        file = file[index+1:]
                }</span>
        } else<span class="cov0" title="0"> {
                file = "???"
        }</span>
        <span class="cov8" title="1">if line == 0 </span><span class="cov0" title="0">{
                line = 1
        }</span>
        <span class="cov8" title="1">buf := new(strings.Builder)
        // Every line is indented at least 4 spaces.
        buf.WriteString("    ")
        fmt.Fprintf(buf, "%s:%d: ", file, line)
        lines := strings.Split(s, "\n")
        if l := len(lines); l &gt; 1 &amp;&amp; lines[l-1] == "" </span><span class="cov8" title="1">{
                lines = lines[:l-1]
        }</span>
        <span class="cov8" title="1">for i, line := range lines </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        // Second and subsequent lines are indented an additional 4 spaces.
                        buf.WriteString("\n        ")
                }</span>
                <span class="cov8" title="1">buf.WriteString(line)</span>
        }
        <span class="cov8" title="1">buf.WriteByte('\n')
        return buf.String()</span>
}

// flushToParent writes c.output to the parent after first writing the header
// with the given format and arguments.
func (c *common) flushToParent(testName, format string, args ...any) <span class="cov8" title="1">{
        p := c.parent
        p.mu.Lock()
        defer p.mu.Unlock()

        c.mu.Lock()
        defer c.mu.Unlock()

        if len(c.output) &gt; 0 </span><span class="cov8" title="1">{
                format += "%s"
                args = append(args[:len(args):len(args)], c.output)
                c.output = c.output[:0] // but why?
        }</span>

        <span class="cov8" title="1">if c.chatty != nil &amp;&amp; p.w == c.chatty.w </span><span class="cov8" title="1">{
                // We're flushing to the actual output, so track that this output is
                // associated with a specific test (and, specifically, that the next output
                // is *not* associated with that test).
                //
                // Moreover, if c.output is non-empty it is important that this write be
                // atomic with respect to the output of other tests, so that we don't end up
                // with confusing '=== CONT' lines in the middle of our '--- PASS' block.
                // Neither humans nor cmd/test2json can parse those easily.
                // (See https://golang.org/issue/40771.)
                c.chatty.Updatef(testName, format, args...)
        }</span> else<span class="cov8" title="1"> {
                // We're flushing to the output buffer of the parent test, which will
                // itself follow a test-name header when it is finally flushed to stdout.
                fmt.Fprintf(p.w, format, args...)
        }</span>
}

type indenter struct {
        c *common
}

func (w indenter) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        n = len(b)
        for len(b) &gt; 0 </span><span class="cov8" title="1">{
                end := bytes.IndexByte(b, '\n')
                if end == -1 </span><span class="cov0" title="0">{
                        end = len(b)
                }</span> else<span class="cov8" title="1"> {
                        end++
                }</span>
                // An indent of 4 spaces will neatly align the dashes with the status
                // indicator of the parent.
                <span class="cov8" title="1">const indent = "    "
                w.c.output = append(w.c.output, indent...)
                w.c.output = append(w.c.output, b[:end]...)
                b = b[end:]</span>
        }
        <span class="cov8" title="1">return</span>
}

// fmtDuration returns a string representing d in the form "87.00s".
func fmtDuration(d time.Duration) string <span class="cov8" title="1">{
        return fmt.Sprintf("%.2fs", d.Seconds())
}</span>

// TB is the interface common to T, B, and F.
type TB interface {
        Cleanup(func())
        Error(args ...any)
        Errorf(format string, args ...any)
        Fail()
        FailNow()
        Failed() bool
        Fatal(args ...any)
        Fatalf(format string, args ...any)
        Helper()
        Log(args ...any)
        Logf(format string, args ...any)
        Name() string
        Setenv(key, value string)
        Skip(args ...any)
        SkipNow()
        Skipf(format string, args ...any)
        Skipped() bool
        TempDir() string

        // A private method to prevent users implementing the
        // interface and so future additions to it will not
        // violate Go 1 compatibility.
        private()
}

var _ TB = (*T)(nil)
var _ TB = (*B)(nil)

// T is a type passed to Test functions to manage test state and support formatted test logs.
//
// A test ends when its Test function returns or calls any of the methods
// FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as
// the Parallel method, must be called only from the goroutine running the
// Test function.
//
// The other reporting methods, such as the variations of Log and Error,
// may be called simultaneously from multiple goroutines.
type T struct {
        common
        isParallel bool
        isEnvSet   bool
        context    *testContext // For running tests and subtests.
}

func (c *common) private() {<span class="cov0" title="0">}</span>

// Name returns the name of the running (sub-) test or benchmark.
//
// The name will include the name of the test along with the names of
// any nested sub-tests. If two sibling sub-tests have the same name,
// Name will append a suffix to guarantee the returned name is unique.
func (c *common) Name() string <span class="cov8" title="1">{
        return c.name
}</span>

func (c *common) setRan() <span class="cov8" title="1">{
        if c.parent != nil </span><span class="cov8" title="1">{
                c.parent.setRan()
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.ran = true</span>
}

// Fail marks the function as having failed but continues execution.
func (c *common) Fail() <span class="cov8" title="1">{
        if c.parent != nil </span><span class="cov8" title="1">{
                c.parent.Fail()
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        // c.done needs to be locked to synchronize checks to c.done in parent tests.
        if c.done </span><span class="cov8" title="1">{
                panic("Fail in goroutine after " + c.name + " has completed")</span>
        }
        <span class="cov8" title="1">c.failed = true</span>
}

// Failed reports whether the function has failed.
func (c *common) Failed() bool <span class="cov8" title="1">{
        c.mu.RLock()
        failed := c.failed
        c.mu.RUnlock()
        return failed || c.raceErrors+race.Errors() &gt; 0
}</span>

// FailNow marks the function as having failed and stops its execution
// by calling runtime.Goexit (which then runs all deferred calls in the
// current goroutine).
// Execution will continue at the next test or benchmark.
// FailNow must be called from the goroutine running the
// test or benchmark function, not from other goroutines
// created during the test. Calling FailNow does not stop
// those other goroutines.
func (c *common) FailNow() <span class="cov8" title="1">{
        c.checkFuzzFn("FailNow")
        c.Fail()

        // Calling runtime.Goexit will exit the goroutine, which
        // will run the deferred functions in this goroutine,
        // which will eventually run the deferred lines in tRunner,
        // which will signal to the test loop that this test is done.
        //
        // A previous version of this code said:
        //
        //        c.duration = ...
        //        c.signal &lt;- c.self
        //        runtime.Goexit()
        //
        // This previous version duplicated code (those lines are in
        // tRunner no matter what), but worse the goroutine teardown
        // implicit in runtime.Goexit was not guaranteed to complete
        // before the test exited. If a test deferred an important cleanup
        // function (like removing temporary files), there was no guarantee
        // it would run on a test failure. Because we send on c.signal during
        // a top-of-stack deferred function now, we know that the send
        // only happens after any other stacked defers have completed.
        c.mu.Lock()
        c.finished = true
        c.mu.Unlock()
        runtime.Goexit()
}</span>

// log generates the output. It's always at the same stack depth.
func (c *common) log(s string) <span class="cov8" title="1">{
        c.logDepth(s, 3) // logDepth + log + public function
}</span>

// logDepth generates the output at an arbitrary stack depth.
func (c *common) logDepth(s string, depth int) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.done </span><span class="cov8" title="1">{
                // This test has already finished. Try and log this message
                // with our parent. If we don't have a parent, panic.
                for parent := c.parent; parent != nil; parent = parent.parent </span><span class="cov8" title="1">{
                        parent.mu.Lock()
                        defer parent.mu.Unlock()
                        if !parent.done </span><span class="cov8" title="1">{
                                parent.output = append(parent.output, parent.decorate(s, depth+1)...)
                                return
                        }</span>
                }
                <span class="cov8" title="1">panic("Log in goroutine after " + c.name + " has completed: " + s)</span>
        } else<span class="cov8" title="1"> {
                if c.chatty != nil </span><span class="cov8" title="1">{
                        if c.bench </span><span class="cov0" title="0">{
                                // Benchmarks don't print === CONT, so we should skip the test
                                // printer and just print straight to stdout.
                                fmt.Print(c.decorate(s, depth+1))
                        }</span> else<span class="cov8" title="1"> {
                                c.chatty.Printf(c.name, "%s", c.decorate(s, depth+1))
                        }</span>

                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">c.output = append(c.output, c.decorate(s, depth+1)...)</span>
        }
}

// Log formats its arguments using default formatting, analogous to Println,
// and records the text in the error log. For tests, the text will be printed only if
// the test fails or the -test.v flag is set. For benchmarks, the text is always
// printed to avoid having performance depend on the value of the -test.v flag.
func (c *common) Log(args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Log")
        c.log(fmt.Sprintln(args...))
}</span>

// Logf formats its arguments according to the format, analogous to Printf, and
// records the text in the error log. A final newline is added if not provided. For
// tests, the text will be printed only if the test fails or the -test.v flag is
// set. For benchmarks, the text is always printed to avoid having performance
// depend on the value of the -test.v flag.
func (c *common) Logf(format string, args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Logf")
        c.log(fmt.Sprintf(format, args...))
}</span>

// Error is equivalent to Log followed by Fail.
func (c *common) Error(args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Error")
        c.log(fmt.Sprintln(args...))
        c.Fail()
}</span>

// Errorf is equivalent to Logf followed by Fail.
func (c *common) Errorf(format string, args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Errorf")
        c.log(fmt.Sprintf(format, args...))
        c.Fail()
}</span>

// Fatal is equivalent to Log followed by FailNow.
func (c *common) Fatal(args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Fatal")
        c.log(fmt.Sprintln(args...))
        c.FailNow()
}</span>

// Fatalf is equivalent to Logf followed by FailNow.
func (c *common) Fatalf(format string, args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Fatalf")
        c.log(fmt.Sprintf(format, args...))
        c.FailNow()
}</span>

// Skip is equivalent to Log followed by SkipNow.
func (c *common) Skip(args ...any) <span class="cov8" title="1">{
        c.checkFuzzFn("Skip")
        c.log(fmt.Sprintln(args...))
        c.SkipNow()
}</span>

// Skipf is equivalent to Logf followed by SkipNow.
func (c *common) Skipf(format string, args ...any) <span class="cov0" title="0">{
        c.checkFuzzFn("Skipf")
        c.log(fmt.Sprintf(format, args...))
        c.SkipNow()
}</span>

// SkipNow marks the test as having been skipped and stops its execution
// by calling runtime.Goexit.
// If a test fails (see Error, Errorf, Fail) and is then skipped,
// it is still considered to have failed.
// Execution will continue at the next test or benchmark. See also FailNow.
// SkipNow must be called from the goroutine running the test, not from
// other goroutines created during the test. Calling SkipNow does not stop
// those other goroutines.
func (c *common) SkipNow() <span class="cov8" title="1">{
        c.checkFuzzFn("SkipNow")
        c.mu.Lock()
        c.skipped = true
        c.finished = true
        c.mu.Unlock()
        runtime.Goexit()
}</span>

// Skipped reports whether the test was skipped.
func (c *common) Skipped() bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.skipped
}</span>

// Helper marks the calling function as a test helper function.
// When printing file and line information, that function will be skipped.
// Helper may be called simultaneously from multiple goroutines.
func (c *common) Helper() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        if c.helperPCs == nil </span><span class="cov8" title="1">{
                c.helperPCs = make(map[uintptr]struct{})
        }</span>
        // repeating code from callerName here to save walking a stack frame
        <span class="cov8" title="1">var pc [1]uintptr
        n := runtime.Callers(2, pc[:]) // skip runtime.Callers + Helper
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">if _, found := c.helperPCs[pc[0]]; !found </span><span class="cov8" title="1">{
                c.helperPCs[pc[0]] = struct{}{}
                c.helperNames = nil // map will be recreated next time it is needed
        }</span>
}

// Cleanup registers a function to be called when the test (or subtest) and all its
// subtests complete. Cleanup functions will be called in last added,
// first called order.
func (c *common) Cleanup(f func()) <span class="cov8" title="1">{
        c.checkFuzzFn("Cleanup")
        var pc [maxStackLen]uintptr
        // Skip two extra frames to account for this function and runtime.Callers itself.
        n := runtime.Callers(2, pc[:])
        cleanupPc := pc[:n]

        fn := func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        c.mu.Lock()
                        defer c.mu.Unlock()
                        c.cleanupName = ""
                        c.cleanupPc = nil
                }</span>()

                <span class="cov8" title="1">name := callerName(0)
                c.mu.Lock()
                c.cleanupName = name
                c.cleanupPc = cleanupPc
                c.mu.Unlock()

                f()</span>
        }

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.cleanups = append(c.cleanups, fn)</span>
}

// TempDir returns a temporary directory for the test to use.
// The directory is automatically removed by Cleanup when the test and
// all its subtests complete.
// Each subsequent call to t.TempDir returns a unique directory;
// if the directory creation fails, TempDir terminates the test by calling Fatal.
func (c *common) TempDir() string <span class="cov8" title="1">{
        c.checkFuzzFn("TempDir")
        // Use a single parent directory for all the temporary directories
        // created by a test, each numbered sequentially.
        c.tempDirMu.Lock()
        var nonExistent bool
        if c.tempDir == "" </span><span class="cov8" title="1">{ // Usually the case with js/wasm
                nonExistent = true
        }</span> else<span class="cov8" title="1"> {
                _, err := os.Stat(c.tempDir)
                nonExistent = os.IsNotExist(err)
                if err != nil &amp;&amp; !nonExistent </span><span class="cov0" title="0">{
                        c.Fatalf("TempDir: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if nonExistent </span><span class="cov8" title="1">{
                c.Helper()

                // Drop unusual characters (such as path separators or
                // characters interacting with globs) from the directory name to
                // avoid surprising os.MkdirTemp behavior.
                mapper := func(r rune) rune </span><span class="cov8" title="1">{
                        if r &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                                const allowed = "!#$%&amp;()+,-.=@^_{}~ "
                                if '0' &lt;= r &amp;&amp; r &lt;= '9' ||
                                        'a' &lt;= r &amp;&amp; r &lt;= 'z' ||
                                        'A' &lt;= r &amp;&amp; r &lt;= 'Z' </span><span class="cov8" title="1">{
                                        return r
                                }</span>
                                <span class="cov8" title="1">if strings.ContainsRune(allowed, r) </span><span class="cov8" title="1">{
                                        return r
                                }</span>
                        } else<span class="cov8" title="1"> if unicode.IsLetter(r) || unicode.IsNumber(r) </span><span class="cov8" title="1">{
                                return r
                        }</span>
                        <span class="cov8" title="1">return -1</span>
                }
                <span class="cov8" title="1">pattern := strings.Map(mapper, c.Name())
                c.tempDir, c.tempDirErr = os.MkdirTemp("", pattern)
                if c.tempDirErr == nil </span><span class="cov8" title="1">{
                        c.Cleanup(func() </span><span class="cov8" title="1">{
                                if err := removeAll(c.tempDir); err != nil </span><span class="cov0" title="0">{
                                        c.Errorf("TempDir RemoveAll cleanup: %v", err)
                                }</span>
                        })
                }
        }
        <span class="cov8" title="1">c.tempDirMu.Unlock()

        if c.tempDirErr != nil </span><span class="cov0" title="0">{
                c.Fatalf("TempDir: %v", c.tempDirErr)
        }</span>
        <span class="cov8" title="1">seq := atomic.AddInt32(&amp;c.tempDirSeq, 1)
        dir := fmt.Sprintf("%s%c%03d", c.tempDir, os.PathSeparator, seq)
        if err := os.Mkdir(dir, 0777); err != nil </span><span class="cov0" title="0">{
                c.Fatalf("TempDir: %v", err)
        }</span>
        <span class="cov8" title="1">return dir</span>
}

// removeAll is like os.RemoveAll, but retries Windows "Access is denied."
// errors up to an arbitrary timeout.
//
// Those errors have been known to occur spuriously on at least the
// windows-amd64-2012 builder (https://go.dev/issue/50051), and can only occur
// legitimately if the test leaves behind a temp file that either is still open
// or the test otherwise lacks permission to delete. In the case of legitimate
// failures, a failing test may take a bit longer to fail, but once the test is
// fixed the extra latency will go away.
func removeAll(path string) error <span class="cov8" title="1">{
        const arbitraryTimeout = 2 * time.Second
        var (
                start     time.Time
                nextSleep = 1 * time.Millisecond
        )
        for </span><span class="cov8" title="1">{
                err := os.RemoveAll(path)
                if !isWindowsRetryable(err) </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">if start.IsZero() </span><span class="cov0" title="0">{
                        start = time.Now()
                }</span> else<span class="cov0" title="0"> if d := time.Since(start) + nextSleep; d &gt;= arbitraryTimeout </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">time.Sleep(nextSleep)
                nextSleep += time.Duration(rand.Int63n(int64(nextSleep)))</span>
        }
}

// Setenv calls os.Setenv(key, value) and uses Cleanup to
// restore the environment variable to its original value
// after the test.
//
// This cannot be used in parallel tests.
func (c *common) Setenv(key, value string) <span class="cov8" title="1">{
        c.checkFuzzFn("Setenv")
        prevValue, ok := os.LookupEnv(key)

        if err := os.Setenv(key, value); err != nil </span><span class="cov0" title="0">{
                c.Fatalf("cannot set environment variable: %v", err)
        }</span>

        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                c.Cleanup(func() </span><span class="cov8" title="1">{
                        os.Setenv(key, prevValue)
                }</span>)
        } else<span class="cov8" title="1"> {
                c.Cleanup(func() </span><span class="cov8" title="1">{
                        os.Unsetenv(key)
                }</span>)
        }
}

// panicHanding is an argument to runCleanup.
type panicHandling int

const (
        normalPanic panicHandling = iota
        recoverAndReturnPanic
)

// runCleanup is called at the end of the test.
// If catchPanic is true, this will catch panics, and return the recovered
// value if any.
func (c *common) runCleanup(ph panicHandling) (panicVal any) <span class="cov8" title="1">{
        if ph == recoverAndReturnPanic </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        panicVal = recover()
                }</span>()
        }

        // Make sure that if a cleanup function panics,
        // we still run the remaining cleanup functions.
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                c.mu.Lock()
                recur := len(c.cleanups) &gt; 0
                c.mu.Unlock()
                if recur </span><span class="cov8" title="1">{
                        c.runCleanup(normalPanic)
                }</span>
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var cleanup func()
                c.mu.Lock()
                if len(c.cleanups) &gt; 0 </span><span class="cov8" title="1">{
                        last := len(c.cleanups) - 1
                        cleanup = c.cleanups[last]
                        c.cleanups = c.cleanups[:last]
                }</span>
                <span class="cov8" title="1">c.mu.Unlock()
                if cleanup == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">cleanup()</span>
        }
}

// callerName gives the function name (qualified with a package path)
// for the caller after skip frames (where 0 means the current function).
func callerName(skip int) string <span class="cov8" title="1">{
        var pc [1]uintptr
        n := runtime.Callers(skip+2, pc[:]) // skip + runtime.Callers + callerName
        if n == 0 </span><span class="cov0" title="0">{
                panic("testing: zero callers found")</span>
        }
        <span class="cov8" title="1">return pcToName(pc[0])</span>
}

func pcToName(pc uintptr) string <span class="cov8" title="1">{
        pcs := []uintptr{pc}
        frames := runtime.CallersFrames(pcs)
        frame, _ := frames.Next()
        return frame.Function
}</span>

// Parallel signals that this test is to be run in parallel with (and only with)
// other parallel tests. When a test is run multiple times due to use of
// -test.count or -test.cpu, multiple instances of a single test never run in
// parallel with each other.
func (t *T) Parallel() <span class="cov8" title="1">{
        if t.isParallel </span><span class="cov0" title="0">{
                panic("testing: t.Parallel called multiple times")</span>
        }
        <span class="cov8" title="1">if t.isEnvSet </span><span class="cov8" title="1">{
                panic("testing: t.Parallel called after t.Setenv; cannot set environment variables in parallel tests")</span>
        }
        <span class="cov8" title="1">t.isParallel = true
        if t.parent.barrier == nil </span><span class="cov0" title="0">{
                // T.Parallel has no effect when fuzzing.
                // Multiple processes may run in parallel, but only one input can run at a
                // time per process so we can attribute crashes to specific inputs.
                return
        }</span>

        // We don't want to include the time we spend waiting for serial tests
        // in the test duration. Record the elapsed time thus far and reset the
        // timer afterwards.
        <span class="cov8" title="1">t.duration += time.Since(t.start)

        // Add to the list of tests to be released by the parent.
        t.parent.sub = append(t.parent.sub, t)
        t.raceErrors += race.Errors()

        if t.chatty != nil </span><span class="cov0" title="0">{
                // Unfortunately, even though PAUSE indicates that the named test is *no
                // longer* running, cmd/test2json interprets it as changing the active test
                // for the purpose of log parsing. We could fix cmd/test2json, but that
                // won't fix existing deployments of third-party tools that already shell
                // out to older builds of cmd/test2json — so merely fixing cmd/test2json
                // isn't enough for now.
                t.chatty.Updatef(t.name, "=== PAUSE %s\n", t.name)
        }</span>

        <span class="cov8" title="1">t.signal &lt;- true   // Release calling test.
        &lt;-t.parent.barrier // Wait for the parent test to complete.
        t.context.waitParallel()

        if t.chatty != nil </span><span class="cov0" title="0">{
                t.chatty.Updatef(t.name, "=== CONT  %s\n", t.name)
        }</span>

        <span class="cov8" title="1">t.start = time.Now()
        t.raceErrors += -race.Errors()</span>
}

// Setenv calls os.Setenv(key, value) and uses Cleanup to
// restore the environment variable to its original value
// after the test.
//
// This cannot be used in parallel tests.
func (t *T) Setenv(key, value string) <span class="cov8" title="1">{
        if t.isParallel </span><span class="cov8" title="1">{
                panic("testing: t.Setenv called after t.Parallel; cannot set environment variables in parallel tests")</span>
        }

        <span class="cov8" title="1">t.isEnvSet = true

        t.common.Setenv(key, value)</span>
}

// InternalTest is an internal type but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
type InternalTest struct {
        Name string
        F    func(*T)
}

var errNilPanicOrGoexit = errors.New("test executed panic(nil) or runtime.Goexit")

func tRunner(t *T, fn func(t *T)) <span class="cov8" title="1">{
        t.runner = callerName(0)

        // When this goroutine is done, either because fn(t)
        // returned normally or because a test failure triggered
        // a call to runtime.Goexit, record the duration and send
        // a signal saying that the test is done.
        defer func() </span><span class="cov8" title="1">{
                if t.Failed() </span><span class="cov8" title="1">{
                        atomic.AddUint32(&amp;numFailed, 1)
                }</span>

                <span class="cov8" title="1">if t.raceErrors+race.Errors() &gt; 0 </span><span class="cov0" title="0">{
                        t.Errorf("race detected during execution of test")
                }</span>

                // Check if the test panicked or Goexited inappropriately.
                //
                // If this happens in a normal test, print output but continue panicking.
                // tRunner is called in its own goroutine, so this terminates the process.
                //
                // If this happens while fuzzing, recover from the panic and treat it like a
                // normal failure. It's important that the process keeps running in order to
                // find short inputs that cause panics.
                <span class="cov8" title="1">err := recover()
                signal := true

                t.mu.RLock()
                finished := t.finished
                t.mu.RUnlock()
                if !finished &amp;&amp; err == nil </span><span class="cov8" title="1">{
                        err = errNilPanicOrGoexit
                        for p := t.parent; p != nil; p = p.parent </span><span class="cov8" title="1">{
                                p.mu.RLock()
                                finished = p.finished
                                p.mu.RUnlock()
                                if finished </span><span class="cov8" title="1">{
                                        t.Errorf("%v: subtest may have called FailNow on a parent test", err)
                                        err = nil
                                        signal = false
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if err != nil &amp;&amp; t.context.isFuzzing </span><span class="cov0" title="0">{
                        prefix := "panic: "
                        if err == errNilPanicOrGoexit </span><span class="cov0" title="0">{
                                prefix = ""
                        }</span>
                        <span class="cov0" title="0">t.Errorf("%s%s\n%s\n", prefix, err, string(debug.Stack()))
                        t.mu.Lock()
                        t.finished = true
                        t.mu.Unlock()
                        err = nil</span>
                }

                // Use a deferred call to ensure that we report that the test is
                // complete even if a cleanup function calls t.FailNow. See issue 41355.
                <span class="cov8" title="1">didPanic := false
                defer func() </span><span class="cov8" title="1">{
                        if didPanic </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        // Only report that the test is complete if it doesn't panic,
                        // as otherwise the test binary can exit before the panic is
                        // reported to the user. See issue 41479.
                        <span class="cov8" title="1">t.signal &lt;- signal</span>
                }()

                <span class="cov8" title="1">doPanic := func(err any) </span><span class="cov0" title="0">{
                        t.Fail()
                        if r := t.runCleanup(recoverAndReturnPanic); r != nil </span><span class="cov0" title="0">{
                                t.Logf("cleanup panicked with %v", r)
                        }</span>
                        // Flush the output log up to the root before dying.
                        <span class="cov0" title="0">for root := &amp;t.common; root.parent != nil; root = root.parent </span><span class="cov0" title="0">{
                                root.mu.Lock()
                                root.duration += time.Since(root.start)
                                d := root.duration
                                root.mu.Unlock()
                                root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))
                                if r := root.parent.runCleanup(recoverAndReturnPanic); r != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(root.parent.w, "cleanup panicked with %v", r)
                                }</span>
                        }
                        <span class="cov0" title="0">didPanic = true
                        panic(err)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        doPanic(err)
                }</span>

                <span class="cov8" title="1">t.duration += time.Since(t.start)

                if len(t.sub) &gt; 0 </span><span class="cov8" title="1">{
                        // Run parallel subtests.
                        // Decrease the running count for this test.
                        t.context.release()
                        // Release the parallel subtests.
                        close(t.barrier)
                        // Wait for subtests to complete.
                        for _, sub := range t.sub </span><span class="cov8" title="1">{
                                &lt;-sub.signal
                        }</span>
                        <span class="cov8" title="1">cleanupStart := time.Now()
                        err := t.runCleanup(recoverAndReturnPanic)
                        t.duration += time.Since(cleanupStart)
                        if err != nil </span><span class="cov0" title="0">{
                                doPanic(err)
                        }</span>
                        <span class="cov8" title="1">if !t.isParallel </span><span class="cov8" title="1">{
                                // Reacquire the count for sequential tests. See comment in Run.
                                t.context.waitParallel()
                        }</span>
                } else<span class="cov8" title="1"> if t.isParallel </span><span class="cov8" title="1">{
                        // Only release the count for this test if it was run as a parallel
                        // test. See comment in Run method.
                        t.context.release()
                }</span>
                <span class="cov8" title="1">t.report() // Report after all subtests have finished.

                // Do not lock t.done to allow race detector to detect race in case
                // the user does not appropriately synchronize a goroutine.
                t.done = true
                if t.parent != nil &amp;&amp; atomic.LoadInt32(&amp;t.hasSub) == 0 </span><span class="cov8" title="1">{
                        t.setRan()
                }</span>
        }()
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if len(t.sub) == 0 </span><span class="cov8" title="1">{
                        t.runCleanup(normalPanic)
                }</span>
        }()

        <span class="cov8" title="1">t.start = time.Now()
        t.raceErrors = -race.Errors()
        fn(t)

        // code beyond here will not be executed when FailNow is invoked
        t.mu.Lock()
        t.finished = true
        t.mu.Unlock()</span>
}

// Run runs f as a subtest of t called name. It runs f in a separate goroutine
// and blocks until f returns or calls t.Parallel to become a parallel test.
// Run reports whether f succeeded (or at least did not fail before calling t.Parallel).
//
// Run may be called simultaneously from multiple goroutines, but all such calls
// must return before the outer test function for t returns.
func (t *T) Run(name string, f func(t *T)) bool <span class="cov8" title="1">{
        atomic.StoreInt32(&amp;t.hasSub, 1)
        testName, ok, _ := t.context.match.fullName(&amp;t.common, name)
        if !ok || shouldFailFast() </span><span class="cov0" title="0">{
                return true
        }</span>
        // Record the stack trace at the point of this call so that if the subtest
        // function - which runs in a separate stack - is marked as a helper, we can
        // continue walking the stack into the parent test.
        <span class="cov8" title="1">var pc [maxStackLen]uintptr
        n := runtime.Callers(2, pc[:])
        t = &amp;T{
                common: common{
                        barrier: make(chan bool),
                        signal:  make(chan bool, 1),
                        name:    testName,
                        parent:  &amp;t.common,
                        level:   t.level + 1,
                        creator: pc[:n],
                        chatty:  t.chatty,
                },
                context: t.context,
        }
        t.w = indenter{&amp;t.common}

        if t.chatty != nil </span><span class="cov8" title="1">{
                t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)
        }</span>
        // Instead of reducing the running count of this test before calling the
        // tRunner and increasing it afterwards, we rely on tRunner keeping the
        // count correct. This ensures that a sequence of sequential tests runs
        // without being preempted, even when their parent is a parallel test. This
        // may especially reduce surprises if *parallel == 1.
        <span class="cov8" title="1">go tRunner(t, f)
        if !&lt;-t.signal </span><span class="cov8" title="1">{
                // At this point, it is likely that FailNow was called on one of the
                // parent tests by one of the subtests. Continue aborting up the chain.
                runtime.Goexit()
        }</span>
        <span class="cov8" title="1">return !t.failed</span>
}

// Deadline reports the time at which the test binary will have
// exceeded the timeout specified by the -timeout flag.
//
// The ok result is false if the -timeout flag indicates “no timeout” (0).
func (t *T) Deadline() (deadline time.Time, ok bool) <span class="cov0" title="0">{
        deadline = t.context.deadline
        return deadline, !deadline.IsZero()
}</span>

// testContext holds all fields that are common to all tests. This includes
// synchronization primitives to run at most *parallel tests.
type testContext struct {
        match    *matcher
        deadline time.Time

        // isFuzzing is true in the context used when generating random inputs
        // for fuzz targets. isFuzzing is false when running normal tests and
        // when running fuzz tests as unit tests (without -fuzz or when -fuzz
        // does not match).
        isFuzzing bool

        mu sync.Mutex

        // Channel used to signal tests that are ready to be run in parallel.
        startParallel chan bool

        // running is the number of tests currently running in parallel.
        // This does not include tests that are waiting for subtests to complete.
        running int

        // numWaiting is the number tests waiting to be run in parallel.
        numWaiting int

        // maxParallel is a copy of the parallel flag.
        maxParallel int
}

func newTestContext(maxParallel int, m *matcher) *testContext <span class="cov8" title="1">{
        return &amp;testContext{
                match:         m,
                startParallel: make(chan bool),
                maxParallel:   maxParallel,
                running:       1, // Set the count to 1 for the main (sequential) test.
        }
}</span>

func (c *testContext) waitParallel() <span class="cov8" title="1">{
        c.mu.Lock()
        if c.running &lt; c.maxParallel </span><span class="cov8" title="1">{
                c.running++
                c.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">c.numWaiting++
        c.mu.Unlock()
        &lt;-c.startParallel</span>
}

func (c *testContext) release() <span class="cov8" title="1">{
        c.mu.Lock()
        if c.numWaiting == 0 </span><span class="cov8" title="1">{
                c.running--
                c.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">c.numWaiting--
        c.mu.Unlock()
        c.startParallel &lt;- true</span> // Pick a waiting test to be run.
}

// No one should be using func Main anymore.
// See the doc comment on func Main and use MainStart instead.
var errMain = errors.New("testing: unexpected use of func Main")

type matchStringOnly func(pat, str string) (bool, error)

func (f matchStringOnly) MatchString(pat, str string) (bool, error)   <span class="cov0" title="0">{ return f(pat, str) }</span>
func (f matchStringOnly) StartCPUProfile(w io.Writer) error           <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) StopCPUProfile()                             {<span class="cov0" title="0">}</span>
func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) ImportPath() string                          <span class="cov0" title="0">{ return "" }</span>
func (f matchStringOnly) StartTestLog(io.Writer)                      {<span class="cov0" title="0">}</span>
func (f matchStringOnly) StopTestLog() error                          <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) SetPanicOnExit0(bool)                        {<span class="cov0" title="0">}</span>
func (f matchStringOnly) CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error <span class="cov0" title="0">{
        return errMain
}</span>
func (f matchStringOnly) RunFuzzWorker(func(corpusEntry) error) error <span class="cov0" title="0">{ return errMain }</span>
func (f matchStringOnly) ReadCorpus(string, []reflect.Type) ([]corpusEntry, error) <span class="cov0" title="0">{
        return nil, errMain
}</span>
func (f matchStringOnly) CheckCorpus([]any, []reflect.Type) error <span class="cov0" title="0">{ return nil }</span>
func (f matchStringOnly) ResetCoverage()                          {<span class="cov0" title="0">}</span>
func (f matchStringOnly) SnapshotCoverage()                       {<span class="cov0" title="0">}</span>

// Main is an internal function, part of the implementation of the "go test" command.
// It was exported because it is cross-package and predates "internal" packages.
// It is no longer used by "go test" but preserved, as much as possible, for other
// systems that simulate "go test" using Main, but Main sometimes cannot be updated as
// new functionality is added to the testing package.
// Systems simulating "go test" should be updated to use MainStart.
func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) <span class="cov0" title="0">{
        os.Exit(MainStart(matchStringOnly(matchString), tests, benchmarks, nil, examples).Run())
}</span>

// M is a type passed to a TestMain function to run the actual tests.
type M struct {
        deps        testDeps
        tests       []InternalTest
        benchmarks  []InternalBenchmark
        fuzzTargets []InternalFuzzTarget
        examples    []InternalExample

        timer     *time.Timer
        afterOnce sync.Once

        numRun int

        // value to pass to os.Exit, the outer test func main
        // harness calls os.Exit with this code. See #34129.
        exitCode int
}

// testDeps is an internal interface of functionality that is
// passed into this package by a test's generated main package.
// The canonical implementation of this interface is
// testing/internal/testdeps's TestDeps.
type testDeps interface {
        ImportPath() string
        MatchString(pat, str string) (bool, error)
        SetPanicOnExit0(bool)
        StartCPUProfile(io.Writer) error
        StopCPUProfile()
        StartTestLog(io.Writer)
        StopTestLog() error
        WriteProfileTo(string, io.Writer, int) error
        CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error
        RunFuzzWorker(func(corpusEntry) error) error
        ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)
        CheckCorpus([]any, []reflect.Type) error
        ResetCoverage()
        SnapshotCoverage()
}

// MainStart is meant for use by tests generated by 'go test'.
// It is not meant to be called directly and is not subject to the Go 1 compatibility document.
// It may change signature from release to release.
func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M <span class="cov8" title="1">{
        Init()
        return &amp;M{
                deps:        deps,
                tests:       tests,
                benchmarks:  benchmarks,
                fuzzTargets: fuzzTargets,
                examples:    examples,
        }
}</span>

// Run runs the tests. It returns an exit code to pass to os.Exit.
func (m *M) Run() (code int) <span class="cov8" title="1">{
        defer func() </span><span class="cov0" title="0">{
                code = m.exitCode
        }</span>()

        // Count the number of calls to m.Run.
        // We only ever expected 1, but we didn't enforce that,
        // and now there are tests in the wild that call m.Run multiple times.
        // Sigh. golang.org/issue/23129.
        <span class="cov8" title="1">m.numRun++

        // TestMain may have already called flag.Parse.
        if !flag.Parsed() </span><span class="cov8" title="1">{
                flag.Parse()
        }</span>

        <span class="cov8" title="1">if *parallel &lt; 1 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: -parallel can only be given a positive integer")
                flag.Usage()
                m.exitCode = 2
                return
        }</span>
        <span class="cov8" title="1">if *matchFuzz != "" &amp;&amp; *fuzzCacheDir == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: -test.fuzzcachedir must be set if -test.fuzz is set")
                flag.Usage()
                m.exitCode = 2
                return
        }</span>

        <span class="cov8" title="1">if len(*matchList) != 0 </span><span class="cov0" title="0">{
                listTests(m.deps.MatchString, m.tests, m.benchmarks, m.fuzzTargets, m.examples)
                m.exitCode = 0
                return
        }</span>

        <span class="cov8" title="1">if *shuffle != "off" </span><span class="cov0" title="0">{
                var n int64
                var err error
                if *shuffle == "on" </span><span class="cov0" title="0">{
                        n = time.Now().UnixNano()
                }</span> else<span class="cov0" title="0"> {
                        n, err = strconv.ParseInt(*shuffle, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, `testing: -shuffle should be "off", "on", or a valid integer:`, err)
                                m.exitCode = 2
                                return
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println("-test.shuffle", n)
                rng := rand.New(rand.NewSource(n))
                rng.Shuffle(len(m.tests), func(i, j int) </span><span class="cov0" title="0">{ m.tests[i], m.tests[j] = m.tests[j], m.tests[i] }</span>)
                <span class="cov0" title="0">rng.Shuffle(len(m.benchmarks), func(i, j int) </span><span class="cov0" title="0">{ m.benchmarks[i], m.benchmarks[j] = m.benchmarks[j], m.benchmarks[i] }</span>)
        }

        <span class="cov8" title="1">parseCpuList()

        m.before()
        defer m.after()

        // Run tests, examples, and benchmarks unless this is a fuzz worker process.
        // Workers start after this is done by their parent process, and they should
        // not repeat this work.
        if !*isFuzzWorker </span><span class="cov8" title="1">{
                deadline := m.startAlarm()
                haveExamples = len(m.examples) &gt; 0
                testRan, testOk := runTests(m.deps.MatchString, m.tests, deadline)
                fuzzTargetsRan, fuzzTargetsOk := runFuzzTests(m.deps, m.fuzzTargets, deadline)
                exampleRan, exampleOk := runExamples(m.deps.MatchString, m.examples)
                m.stopAlarm()
                if !testRan &amp;&amp; !exampleRan &amp;&amp; !fuzzTargetsRan &amp;&amp; *matchBenchmarks == "" &amp;&amp; *matchFuzz == "" </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")
                }</span>
                <span class="cov8" title="1">if !testOk || !exampleOk || !fuzzTargetsOk || !runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks) || race.Errors() &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("FAIL")
                        m.exitCode = 1
                        return
                }</span>
        }

        <span class="cov8" title="1">fuzzingOk := runFuzzing(m.deps, m.fuzzTargets)
        if !fuzzingOk </span><span class="cov0" title="0">{
                fmt.Println("FAIL")
                if *isFuzzWorker </span><span class="cov0" title="0">{
                        m.exitCode = fuzzWorkerExitCode
                }</span> else<span class="cov0" title="0"> {
                        m.exitCode = 1
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">m.exitCode = 0
        if !*isFuzzWorker </span><span class="cov8" title="1">{
                fmt.Println("PASS")
        }</span>
        <span class="cov8" title="1">return</span>
}

func (t *T) report() <span class="cov8" title="1">{
        if t.parent == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">dstr := fmtDuration(t.duration)
        format := "--- %s: %s (%s)\n"
        if t.Failed() </span><span class="cov8" title="1">{
                t.flushToParent(t.name, format, "FAIL", t.name, dstr)
        }</span> else<span class="cov8" title="1"> if t.chatty != nil </span><span class="cov8" title="1">{
                if t.Skipped() </span><span class="cov8" title="1">{
                        t.flushToParent(t.name, format, "SKIP", t.name, dstr)
                }</span> else<span class="cov8" title="1"> {
                        t.flushToParent(t.name, format, "PASS", t.name, dstr)
                }</span>
        }
}

func listTests(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) <span class="cov0" title="0">{
        if _, err := matchString(*matchList, "non-empty"); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: invalid regexp in -test.list (%q): %s\n", *matchList, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">for _, test := range tests </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, test.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(test.Name)
                }</span>
        }
        <span class="cov0" title="0">for _, bench := range benchmarks </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, bench.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(bench.Name)
                }</span>
        }
        <span class="cov0" title="0">for _, fuzzTarget := range fuzzTargets </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, fuzzTarget.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(fuzzTarget.Name)
                }</span>
        }
        <span class="cov0" title="0">for _, example := range examples </span><span class="cov0" title="0">{
                if ok, _ := matchString(*matchList, example.Name); ok </span><span class="cov0" title="0">{
                        fmt.Println(example.Name)
                }</span>
        }
}

// RunTests is an internal function but exported because it is cross-package;
// it is part of the implementation of the "go test" command.
func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool) <span class="cov0" title="0">{
        var deadline time.Time
        if *timeout &gt; 0 </span><span class="cov0" title="0">{
                deadline = time.Now().Add(*timeout)
        }</span>
        <span class="cov0" title="0">ran, ok := runTests(matchString, tests, deadline)
        if !ran &amp;&amp; !haveExamples </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")
        }</span>
        <span class="cov0" title="0">return ok</span>
}

func runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool) <span class="cov8" title="1">{
        ok = true
        for _, procs := range cpuList </span><span class="cov8" title="1">{
                runtime.GOMAXPROCS(procs)
                for i := uint(0); i &lt; *count; i++ </span><span class="cov8" title="1">{
                        if shouldFailFast() </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if i &gt; 0 &amp;&amp; !ran </span><span class="cov0" title="0">{
                                // There were no tests to run on the first
                                // iteration. This won't change, so no reason
                                // to keep trying.
                                break</span>
                        }
                        <span class="cov8" title="1">ctx := newTestContext(*parallel, newMatcher(matchString, *match, "-test.run"))
                        ctx.deadline = deadline
                        t := &amp;T{
                                common: common{
                                        signal:  make(chan bool, 1),
                                        barrier: make(chan bool),
                                        w:       os.Stdout,
                                },
                                context: ctx,
                        }
                        if Verbose() </span><span class="cov0" title="0">{
                                t.chatty = newChattyPrinter(t.w)
                        }</span>
                        <span class="cov8" title="1">tRunner(t, func(t *T) </span><span class="cov8" title="1">{
                                for _, test := range tests </span><span class="cov8" title="1">{
                                        t.Run(test.Name, test.F)
                                }</span>
                        })
                        <span class="cov8" title="1">select </span>{
                        case &lt;-t.signal:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                panic("internal error: tRunner exited without sending on t.signal")</span>
                        }
                        <span class="cov8" title="1">ok = ok &amp;&amp; !t.Failed()
                        ran = ran || t.ran</span>
                }
        }
        <span class="cov8" title="1">return ran, ok</span>
}

// before runs before all testing.
func (m *M) before() <span class="cov8" title="1">{
        if *memProfileRate &gt; 0 </span><span class="cov0" title="0">{
                runtime.MemProfileRate = *memProfileRate
        }</span>
        <span class="cov8" title="1">if *cpuProfile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*cpuProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        return
                }</span>
                <span class="cov0" title="0">if err := m.deps.StartCPUProfile(f); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't start cpu profile: %s\n", err)
                        f.Close()
                        return
                }</span>
                // Could save f so after can call f.Close; not worth the effort.
        }
        <span class="cov8" title="1">if *traceFile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*traceFile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        return
                }</span>
                <span class="cov0" title="0">if err := trace.Start(f); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't start tracing: %s\n", err)
                        f.Close()
                        return
                }</span>
                // Could save f so after can call f.Close; not worth the effort.
        }
        <span class="cov8" title="1">if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 </span><span class="cov0" title="0">{
                runtime.SetBlockProfileRate(*blockProfileRate)
        }</span>
        <span class="cov8" title="1">if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 </span><span class="cov0" title="0">{
                runtime.SetMutexProfileFraction(*mutexProfileFraction)
        }</span>
        <span class="cov8" title="1">if *coverProfile != "" &amp;&amp; cover.Mode == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "testing: cannot use -test.coverprofile because test binary was not built with coverage enabled\n")
                os.Exit(2)
        }</span>
        <span class="cov8" title="1">if *testlog != "" </span><span class="cov0" title="0">{
                // Note: Not using toOutputDir.
                // This file is for use by cmd/go, not users.
                var f *os.File
                var err error
                if m.numRun == 1 </span><span class="cov0" title="0">{
                        f, err = os.Create(*testlog)
                }</span> else<span class="cov0" title="0"> {
                        f, err = os.OpenFile(*testlog, os.O_WRONLY, 0)
                        if err == nil </span><span class="cov0" title="0">{
                                f.Seek(0, io.SeekEnd)
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">m.deps.StartTestLog(f)
                testlogFile = f</span>
        }
        <span class="cov8" title="1">if *panicOnExit0 </span><span class="cov8" title="1">{
                m.deps.SetPanicOnExit0(true)
        }</span>
}

// after runs after all testing.
func (m *M) after() <span class="cov8" title="1">{
        m.afterOnce.Do(func() </span><span class="cov8" title="1">{
                m.writeProfiles()
        }</span>)

        // Restore PanicOnExit0 after every run, because we set it to true before
        // every run. Otherwise, if m.Run is called multiple times the behavior of
        // os.Exit(0) will not be restored after the second run.
        <span class="cov0" title="0">if *panicOnExit0 </span><span class="cov0" title="0">{
                m.deps.SetPanicOnExit0(false)
        }</span>
}

func (m *M) writeProfiles() <span class="cov8" title="1">{
        if *testlog != "" </span><span class="cov0" title="0">{
                if err := m.deps.StopTestLog(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err := testlogFile.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)
                        os.Exit(2)
                }</span>
        }
        <span class="cov8" title="1">if *cpuProfile != "" </span><span class="cov0" title="0">{
                m.deps.StopCPUProfile() // flushes profile to disk
        }</span>
        <span class="cov8" title="1">if *traceFile != "" </span><span class="cov0" title="0">{
                trace.Stop() // flushes trace to disk
        }</span>
        <span class="cov8" title="1">if *memProfile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*memProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">runtime.GC() // materialize all statistics
                if err = m.deps.WriteProfileTo("allocs", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *memProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*blockProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err = m.deps.WriteProfileTo("block", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *blockProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 </span><span class="cov0" title="0">{
                f, err := os.Create(toOutputDir(*mutexProfile))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: %s\n", err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">if err = m.deps.WriteProfileTo("mutex", f, 0); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *mutexProfile, err)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">f.Close()</span>
        }
        <span class="cov8" title="1">if cover.Mode != "" </span><span class="cov8" title="1">{
                coverReport()
        }</span>
}

// toOutputDir returns the file name relocated, if required, to outputDir.
// Simple implementation to avoid pulling in path/filepath.
func toOutputDir(path string) string <span class="cov8" title="1">{
        if *outputDir == "" || path == "" </span><span class="cov8" title="1">{
                return path
        }</span>
        // On Windows, it's clumsy, but we can be almost always correct
        // by just looking for a drive letter and a colon.
        // Absolute paths always have a drive letter (ignoring UNC).
        // Problem: if path == "C:A" and outputdir == "C:\Go" it's unclear
        // what to do, but even then path/filepath doesn't help.
        // TODO: Worth doing better? Probably not, because we're here only
        // under the management of go test.
        <span class="cov0" title="0">if runtime.GOOS == "windows" &amp;&amp; len(path) &gt;= 2 </span><span class="cov0" title="0">{
                letter, colon := path[0], path[1]
                if ('a' &lt;= letter &amp;&amp; letter &lt;= 'z' || 'A' &lt;= letter &amp;&amp; letter &lt;= 'Z') &amp;&amp; colon == ':' </span><span class="cov0" title="0">{
                        // If path starts with a drive letter we're stuck with it regardless.
                        return path
                }</span>
        }
        <span class="cov0" title="0">if os.IsPathSeparator(path[0]) </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%c%s", *outputDir, os.PathSeparator, path)</span>
}

// startAlarm starts an alarm if requested.
func (m *M) startAlarm() time.Time <span class="cov8" title="1">{
        if *timeout &lt;= 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">deadline := time.Now().Add(*timeout)
        m.timer = time.AfterFunc(*timeout, func() </span><span class="cov0" title="0">{
                m.after()
                debug.SetTraceback("all")
                panic(fmt.Sprintf("test timed out after %v", *timeout))</span>
        })
        <span class="cov8" title="1">return deadline</span>
}

// stopAlarm turns off the alarm.
func (m *M) stopAlarm() <span class="cov8" title="1">{
        if *timeout &gt; 0 </span><span class="cov8" title="1">{
                m.timer.Stop()
        }</span>
}

func parseCpuList() <span class="cov8" title="1">{
        for _, val := range strings.Split(*cpuListStr, ",") </span><span class="cov8" title="1">{
                val = strings.TrimSpace(val)
                if val == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">cpu, err := strconv.Atoi(val)
                if err != nil || cpu &lt;= 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "testing: invalid value %q for -test.cpu\n", val)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">cpuList = append(cpuList, cpu)</span>
        }
        <span class="cov8" title="1">if cpuList == nil </span><span class="cov8" title="1">{
                cpuList = append(cpuList, runtime.GOMAXPROCS(-1))
        }</span>
}

func shouldFailFast() bool <span class="cov8" title="1">{
        return *failFast &amp;&amp; atomic.LoadUint32(&amp;numFailed) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !windows

package testing

// isWindowsRetryable reports whether err is a Windows error code
// that may be fixed by retrying a failed filesystem operation.
func isWindowsRetryable(err error) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
